================================================================================
File: /Users/luketchang/code/ticketing/skaffold.yaml
================================================================================
apiVersion: skaffold/v2alpha3
kind: Config
deploy:
  kubectl:
    manifests:
      - ./infra/k8s/*
build:
  local:
    push: false
  # googleCloudBuild:
  #   projectId: ticketing-dev-451322
  artifacts:
    - image: luketchang/auth
      context: .
      docker:
        dockerfile: auth/Dockerfile
      sync:
        manual:
          - src: "auth/src/*.ts"
            dest: .
          - src: "auth/src/**/*.ts"
            dest: .
    - image: luketchang/tickets
      context: .
      docker:
        dockerfile: tickets/Dockerfile
      sync:
        manual:
          - src: "tickets/src/*.ts"
            dest: .
          - src: "tickets/src/**/*.ts"
            dest: .
    - image: luketchang/client
      context: client
      docker:
        dockerfile: Dockerfile
      sync:
        manual:
          - src: "src/**/*.js"
            dest: .
    - image: luketchang/orders
      context: .
      docker:
        dockerfile: orders/Dockerfile
      sync:
        manual:
          - src: "orders/src/**/*.ts"
            dest: .
    - image: luketchang/expiration
      context: .
      docker:
        dockerfile: expiration/Dockerfile
      sync:
        manual:
          - src: "expiration/src/**/*.ts"
            dest: .
    - image: luketchang/payments
      context: .
      docker:
        dockerfile: payments/Dockerfile
      sync:
        manual:
          - src: "payments/src/**/*.ts"
            dest: .


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer;


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';

import { indexTicketRouter } from './routes/index';
import { createTicketRouter } from './routes/new';
import { showTicketRouter } from './routes/show';
import { updateTicketRouter } from './routes/update';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(indexTicketRouter);
app.use(createTicketRouter);
app.use(showTicketRouter);
app.use(updateTicketRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "tickets" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { natsWrapper } from "./nats-wrapper";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { OrderCancelledListener } from "./events/listeners/order-cancelled-listener";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.TICKETS_MONGO_URI)
    throw new Error("TICKETS_MONGO_URI not defined.");
  if (!process.env.NATS_CLIENT_ID)
    throw new Error("NATS_CLIENT_ID not defined.");
  if (!process.env.NATS_CLUSTER_ID)
    throw new Error("NATS_CLUSTER_ID not defined.");
  if (!process.env.NATS_URL) throw new Error("NATS_URL not defined.");

  try {
    await natsWrapper.connect(
      process.env.NATS_CLUSTER_ID,
      process.env.NATS_CLIENT_ID,
      process.env.NATS_URL
    );

    natsWrapper.client.on("close", () => {
      logger.info("NATS connection closed!");
      process.exit();
    });
    process.on("SIGINT", () => natsWrapper.client.close());
    process.on("SIGTERM", () => natsWrapper.client.close());

    new OrderCreatedListener(natsWrapper.client).listen();
    new OrderCancelledListener(natsWrapper.client).listen();

    await mongoose.connect(process.env.TICKETS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");
  } catch (err) {
    logger.error("Error during startup", { error: err });
  }

  app.listen(3000, () => {
    logger.info("Listening on port 3000!");
  });
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = () => {
    const id = mongoose.Types.ObjectId().toHexString();
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from 'mongodb-memory-server';
import mongoose from 'mongoose';

jest.mock('../nats-wrapper');

let mongo: any;
beforeAll(async () => {
    process.env.JWT_KEY = 'JWT_TEST_KEY';
    
    mongo = new MongoMemoryServer();
    const mongoUri = await mongo.getUri();

    await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true
    });
});

beforeEach(async () => {
    jest.clearAllMocks();
    const collections = await mongoose.connection.db.collections();
    for(let collection of collections) {
        await collection.deleteMany({});
    }
});

afterAll(async () => {
    await mongo.stop();
    await mongoose.connection.close();
});

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/createTicket.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const createTicket = async (title: string, price: number, cookie: string[]) => {
    const res = await request(app)
        .post('/api/tickets')
        .set('Cookie', cookie)
        .send({
            title,
            price
        })
        .expect(201);
    
    return res;
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/models/ticket.ts
================================================================================
import mongoose, { Schema } from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current'

interface TicketAttrs {
    title: string;
    price: number;
    userId: string;
}

interface TicketDoc extends mongoose.Document {
    title: string;
    price: number;
    userId: string;
    version: number;
    orderId?: string;
}

interface TicketModel extends mongoose.Model<TicketDoc> {
    build(ticketAttrs: TicketAttrs): TicketDoc;
}

const ticketSchema = new Schema(
    {
        title: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true
        },
        userId: {
            type: String,
            required: true
        },
        orderId: {
            type: String
        }
    }, {
        toJSON: {
            transform(_, ret) {
                ret.id = ret._id;
                delete ret._id;
            }
        }
    }
);

ticketSchema.set('versionKey', 'version');
ticketSchema.plugin(updateIfCurrentPlugin);

ticketSchema.statics.build = (attrs: TicketAttrs) => {
    return new Ticket(attrs);
};

const Ticket = mongoose.model<TicketDoc, TicketModel>('Ticket', ticketSchema);

export { Ticket };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/publishers/ticket-updated-publisher.ts
================================================================================
import { Subject, Publisher, TicketUpdatedEvent } from "@lt-ticketing/common";

export class TicketUpdatedPublisher extends Publisher<TicketUpdatedEvent> {
    subject: Subject.TicketUpdated = Subject.TicketUpdated;
}

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/publishers/ticket-created-publisher.ts
================================================================================
import { Subject, Publisher, TicketCreatedEvent } from "@lt-ticketing/common";

export class TicketCreatedPublisher extends Publisher<TicketCreatedEvent> {
    subject: Subject.TicketCreated = Subject.TicketCreated;
}

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/listeners/order-created-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Listener,
  NotFoundError,
  OrderCreatedEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { TicketUpdatedPublisher } from "../publishers/ticket-updated-publisher";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  subject: Subject.OrderCreated = Subject.OrderCreated;
  queueGroupName = QueueGroupName.TicketsService;

  async onMessage(data: OrderCreatedEvent["data"], msg: Message) {
    logger.info("Order created event received", { orderId: data.id });

    const ticket = await Ticket.findById(data.ticket.id);
    if (!ticket) {
      logger.warn("Ticket not found", { ticketId: data.ticket.id });
      throw new Error("Ticket not found.");
    }

    ticket.set({ orderId: data.id });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    await new TicketUpdatedPublisher(this.client).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    logger.info("Ticket updated event published", { ticketId: ticket.id });

    msg.ack();

    logger.info("Order created event acknowledged", { orderId: data.id });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/listeners/order-cancelled-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Listener,
  NotFoundError,
  OrderCancelledEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { TicketUpdatedPublisher } from "../publishers/ticket-updated-publisher";
import { logger } from "@lt-ticketing/common";

export class OrderCancelledListener extends Listener<OrderCancelledEvent> {
  subject: Subject.OrderCancelled = Subject.OrderCancelled;
  queueGroupName = QueueGroupName.TicketsService;

  async onMessage(data: OrderCancelledEvent["data"], msg: Message) {
    logger.info("Order cancelled event received", { orderId: data.id });

    const ticket = await Ticket.findById(data.ticket.id);
    if (!ticket) {
      logger.warn("Ticket does not exist", { ticketId: data.ticket.id });
      throw new Error("Ticket does not exist.");
    }

    ticket.set({ orderId: undefined });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    await new TicketUpdatedPublisher(this.client).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    logger.info("Ticket updated event published", { ticketId: ticket.id });

    msg.ack();

    logger.info("Order cancelled event acknowledged", { orderId: data.id });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/new.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { requireAuth, validateRequest } from "@lt-ticketing/common";

import { natsWrapper } from "../nats-wrapper";
import { TicketCreatedPublisher } from "../events/publishers/ticket-created-publisher";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/tickets",
  requireAuth,
  [
    body("title").not().isEmpty().withMessage("Title required."),
    body("price").isFloat({ gt: 0 }).withMessage("Price must be > 0"),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { title, price } = req.body;

    logger.info("Received ticket creation request", {
      title,
      price,
      userId: req.currentUser!.id,
    });

    const ticket = Ticket.build({
      title,
      price,
      userId: req.currentUser!.id,
    });

    await ticket.save();

    logger.info("Ticket created", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    await new TicketCreatedPublisher(natsWrapper.client).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    logger.info("Ticket created event published", { ticketId: ticket.id });

    res.status(201).send(ticket);
  }
);

export { router as createTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/index.ts
================================================================================
import express, { Request, Response } from 'express';

import { Ticket } from '../models/ticket';

const router = express.Router();

router.get('/api/tickets', async (req: Request, res: Response) => {
    const tickets = await Ticket.find({});
    res.send(tickets);
});

export { router as indexTicketRouter };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/show.ts
================================================================================
import express, { Request, Response } from "express";
import { NotFoundError } from "@lt-ticketing/common";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get("/api/tickets/:id", async (req: Request, res: Response) => {
  logger.info("Received ticket retrieval request", { ticketId: req.params.id });
  const ticket = await Ticket.findById(req.params.id);
  if (!ticket) {
    logger.warn("Ticket not found", { ticketId: req.params.id });
    throw new NotFoundError();
  }

  logger.info("Ticket retrieved", {
    ticketId: ticket.id,
    title: ticket.title,
    price: ticket.price,
    userId: ticket.userId,
    version: ticket.version,
  });

  res.status(200).send(ticket);
});

export { router as showTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/update.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import {
  NotFoundError,
  NotAuthorizedError,
  BadRequestError,
} from "@lt-ticketing/common";
import { requireAuth, validateRequest } from "@lt-ticketing/common";

import { TicketUpdatedPublisher } from "../events/publishers/ticket-updated-publisher";
import { natsWrapper } from "../nats-wrapper";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.put(
  "/api/tickets/:id",
  requireAuth,
  [
    body("title").not().isEmpty().withMessage("Title required."),
    body("price").isFloat({ gt: 0 }).withMessage("Price must be > 0"),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    logger.info("Received ticket update request", {
      ticketId: req.params.id,
      userId: req.currentUser!.id,
    });
    const ticket = await Ticket.findById(req.params.id);

    if (!ticket) {
      logger.warn("Ticket not found", { ticketId: req.params.id });
      throw new NotFoundError();
    }
    if (ticket.orderId) {
      logger.warn("Cannot edit a reserved ticket", { ticketId: ticket.id });
      throw new BadRequestError("Cannot edit a reserved ticket.");
    }
    if (ticket.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to update ticket", {
        ticketId: ticket.id,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    ticket.set({
      title: req.body.title,
      price: req.body.price,
    });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    await new TicketUpdatedPublisher(natsWrapper.client).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    logger.info("Ticket updated event published", { ticketId: ticket.id });

    res.send(ticket);
  }
);

export { router as updateTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/listener.ts
================================================================================
import nats, { Message, Stan } from 'node-nats-streaming';
import { randomBytes } from 'crypto';
import { TicketCreatedListener } from './events/ticket-created-listener';

console.clear();

const stan = nats.connect('ticketing', randomBytes(4).toString('hex'), {
  url: 'http://localhost:4222',
});

stan.on('connect', () => {
  console.log('Listener connected to NATS');

  stan.on('close', () => {
    console.log('NATS connection closed!');
    process.exit();
  });

  new TicketCreatedListener(stan).listen();
});

process.on('SIGINT', () => stan.close());
process.on('SIGTERM', () => stan.close());

================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/publisher.ts
================================================================================
import nats from 'node-nats-streaming';
import { TicketCreatedPublisher } from './events/ticket-created-publisher';

console.clear();

const stan = nats.connect('ticketing', 'abc', {
  url: 'http://localhost:4222',
});

stan.on('connect', async () => {
  console.log('Publisher connected to NATS');

  const ticketCreatedPublisher = new TicketCreatedPublisher(stan);

  try{
    await ticketCreatedPublisher.publish({
      id: '123',
      title: 'concert',
      price: 20,
      userId: 'userid'
    });
  } catch(err) {
    console.error(err);
  }
  
});


================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/events/ticket-created-listener.ts
================================================================================
import { Subject, Listener, TicketCreatedEvent } from '@lt-ticketing/common';
import { Message } from 'node-nats-streaming';

export class TicketCreatedListener extends Listener<TicketCreatedEvent> {
    readonly subject: Subject.TicketCreated = Subject.TicketCreated;
    queueGroupName = 'payments-service';
    
    onMessage(data: TicketCreatedEvent['data'], msg: Message) {
      console.log('Event data:', data);
      msg.ack();
    }
  }

================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/events/ticket-created-publisher.ts
================================================================================
import { Subject, Publisher, TicketCreatedEvent } from "@lt-ticketing/common";

export class TicketCreatedPublisher extends Publisher<TicketCreatedEvent> {
    subject: Subject.TicketCreated = Subject.TicketCreated;
}

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer;


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/stripe.ts
================================================================================
import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_KEY!, {
    apiVersion: '2020-08-27'
});

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';
import { createChargeRouter } from './routes/new';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(createChargeRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "payments" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { OrderCancelledListener } from "./events/listeners/order-cancelled-listener";
import { natsWrapper } from "./nats-wrapper";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.PAYMENTS_MONGO_URI)
    throw new Error("TICKETS_MONGO_URI not defined.");
  if (!process.env.NATS_CLIENT_ID)
    throw new Error("NATS_CLIENT_ID not defined.");
  if (!process.env.NATS_CLUSTER_ID)
    throw new Error("NATS_CLUSTER_ID not defined.");
  if (!process.env.NATS_URL) throw new Error("NATS_URL not defined.");

  try {
    await natsWrapper.connect(
      process.env.NATS_CLUSTER_ID,
      process.env.NATS_CLIENT_ID,
      process.env.NATS_URL
    );

    natsWrapper.client.on("close", () => {
      logger.info("NATS connection closed! Payment service exiting...");
      process.exit();
    });
    process.on("SIGINT", () => natsWrapper.client.close());
    process.on("SIGTERM", () => natsWrapper.client.close());

    new OrderCreatedListener(natsWrapper.client).listen();
    new OrderCancelledListener(natsWrapper.client).listen();

    await mongoose.connect(process.env.PAYMENTS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");
  } catch (err) {
    logger.error("Error during startup", { error: err });
  }

  app.listen(3000, () => {
    logger.info("Listening on port 3000!");
  });
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/__mocks__/stripe.ts
================================================================================
export const stripe = {
    charges: {
        create: jest.fn().mockResolvedValue({ id: 'MOCK_ID' })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = (id: string) => {
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from 'mongodb-memory-server';
import mongoose from 'mongoose';

jest.mock('../nats-wrapper');

let mongo: any;
beforeAll(async () => {
    process.env.JWT_KEY = 'JWT_TEST_KEY';
    
    mongo = new MongoMemoryServer();
    const mongoUri = await mongo.getUri();

    await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true
    });
});

beforeEach(async () => {
    jest.clearAllMocks();
    const collections = await mongoose.connection.db.collections();
    for(let collection of collections) {
        await collection.deleteMany({});
    }
});

afterAll(async () => {
    await mongo.stop();
    await mongoose.connection.close();
});

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/createTicket.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const createTicket = async (title: string, price: number, cookie: string[]) => {
    const res = await request(app)
        .post('/api/tickets')
        .set('Cookie', cookie)
        .send({
            title,
            price
        })
        .expect(201);
    
    return res;
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/models/payment.ts
================================================================================
import mongoose from 'mongoose';

interface PaymentAttrs {
    orderId: string;
    stripeId: string;
}

interface PaymentDoc extends mongoose.Document {
    orderId: string;
    stripeId: string;
}

interface PaymentModel extends mongoose.Model<PaymentDoc> {
    build(attrs: PaymentAttrs): PaymentDoc;
}

const paymentSchema = new mongoose.Schema({
    orderId: {
        type: String,
        required: true
    },
    stripeId: {
        type: String,
        required: true
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

paymentSchema.statics.build = (attrs: PaymentAttrs) => {
    return new Payment(attrs);
}

const Payment = mongoose.model<PaymentDoc, PaymentModel>('Payment', paymentSchema);

export { Payment };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/models/order.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { OrderStatus } from '@lt-ticketing/common';

interface OrderAttrs {
    id: string;
    price: number;
    userId: string;
    status: OrderStatus;
    version: number;
}

interface OrderDoc extends mongoose.Document {
    price: number;
    userId: string;
    status: OrderStatus;
    version: number;
}

interface OrderModel extends mongoose.Model<OrderDoc> {
    build(attrs: OrderAttrs): OrderDoc;
}

const orderSchema = new mongoose.Schema ({
    userId: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true
    },
    status: {
        type: String,
        required: true,
        enum: Object.values(OrderStatus)
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

orderSchema.set('versionKey', 'version');
orderSchema.plugin(updateIfCurrentPlugin);

orderSchema.statics.build = (attrs: OrderAttrs) => {
    return new Order({
        _id: attrs.id,
        price: attrs.price,
        userId: attrs.userId,
        status: attrs.status,
        version: attrs.version
    });
}

const Order = mongoose.model<OrderDoc, OrderModel>('Order', orderSchema);

export { Order };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/publishers/payment-created-publisher.ts
================================================================================
import { Subject, Publisher, PaymentCreatedEvent } from '@lt-ticketing/common';

export class PaymentCreatedPublisher extends Publisher<PaymentCreatedEvent> {
    subject: Subject.PaymentCreated = Subject.PaymentCreated;
}

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/listeners/order-created-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Listener,
  OrderCreatedEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  subject: Subject.OrderCreated = Subject.OrderCreated;
  queueGroupName = QueueGroupName.PaymentsService;

  async onMessage(data: OrderCreatedEvent["data"], msg: Message) {
    logger.info("Order created event received", { orderId: data.id });

    const order = Order.build({
      id: data.id,
      price: data.ticket.price,
      userId: data.userId,
      status: data.status,
      version: data.version,
    });
    await order.save();

    logger.info("Order created", {
      orderId: order.id,
      userId: order.userId,
      price: order.price,
      status: order.status,
      version: order.version,
    });

    msg.ack();

    logger.info("Order created event acknowledged", { orderId: order.id });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/listeners/order-cancelled-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Listener,
  OrderCancelledEvent,
  OrderStatus,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class OrderCancelledListener extends Listener<OrderCancelledEvent> {
  subject: Subject.OrderCancelled = Subject.OrderCancelled;
  queueGroupName = QueueGroupName.PaymentsService;

  async onMessage(data: OrderCancelledEvent["data"], msg: Message) {
    logger.info("Order cancelled event received", { data });

    const order = await Order.findOne({
      _id: data.id,
      version: data.version - 1,
    });

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found.");
    }

    order.set({ status: OrderStatus.Cancelled });
    await order.save();

    logger.info("Order cancelled", { data });

    msg.ack();

    logger.info("Order cancelled event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/routes/new.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import {
  requireAuth,
  validateRequest,
  BadRequestError,
  NotFoundError,
  NotAuthorizedError,
  OrderStatus,
} from "@lt-ticketing/common";
import { natsWrapper } from "../nats-wrapper";
import { PaymentCreatedPublisher } from "../events/publishers/payment-created-publisher";
import { Order } from "../models/order";
import { Payment } from "../models/payment";
import { stripe } from "../stripe";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/payments",
  requireAuth,
  [body("token").not().isEmpty(), body("orderId").not().isEmpty()],
  validateRequest,
  async (req: Request, res: Response) => {
    const { token, orderId } = req.body;

    logger.info("Received payment creation request", {
      orderId,
      userId: req.currentUser?.id,
    });
    const order = await Order.findById(orderId);

    if (!order) {
      logger.warn("Order not found", { orderId: orderId });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized", {
        orderId: orderId,
        userId: req.currentUser?.id,
      });
      throw new NotAuthorizedError();
    }
    if (order.status === OrderStatus.Cancelled) {
      logger.warn("Cannot pay for cancelled order", { orderId: orderId });
      throw new BadRequestError("Cannot pay for cancelled order.");
    }

    const charge = await stripe.charges.create({
      currency: "usd",
      amount: order.price * 100,
      source: token,
    });

    const payment = Payment.build({
      orderId,
      stripeId: charge.id,
    });
    await payment.save();

    logger.info("Payment created", {
      paymentId: payment.id,
      orderId: payment.orderId,
      stripeId: payment.stripeId,
    });

    await new PaymentCreatedPublisher(natsWrapper.client).publish({
      id: payment.id,
      orderId: payment.orderId,
      stripeId: payment.stripeId,
    });

    logger.info("Payment created event published", { paymentId: payment.id });

    res.status(201).send(payment);
  }
);

export { router as createChargeRouter };


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/debug-pod.yaml
================================================================================
apiVersion: v1
kind: Pod
metadata:
  name: debug-pod
spec:
  serviceAccountName: default
  containers:
    - name: debug
      image: curlimages/curl
      command: ["sh", "-c", "sleep infinity"]
  restartPolicy: Never


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/nats-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nats-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nats
  template:
    metadata:
      labels:
        app: nats
    spec:
      containers:
        - name: nats
          image: nats-streaming:0.17.0
          args: 
            [
              '-p',
              '4222',
              '-m',
              '8222',
              '-hbi',
              '5s',
              '-hbt',
              '5s',
              '-hbf',
              '2',
              '-SD',
              '-cid',
              'ticketing'
            ]
---
apiVersion: v1
kind: Service
metadata:
  name: nats-srv
spec:
  type: ClusterIP
  selector:
    app: nats
  ports:
    - name: client
      protocol: TCP
      port: 4222
      targetPort: 4222
    - name: monitoring
      protocol: TCP
      port: 8222
      targetPort: 8222


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/orders-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orders-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orders-mongo
  template:
    metadata:
      labels:
        app: orders-mongo
    spec:
      containers:
        - name: orders-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: orders-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: orders-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/tickets-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tickets-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tickets-mongo
  template:
    metadata:
      labels:
        app: tickets-mongo
    spec:
      containers:
        - name: tickets-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: tickets-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: tickets-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana-alloy
  namespace: default
  labels:
    app: grafana-alloy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana-alloy
  template:
    metadata:
      labels:
        app: grafana-alloy
    spec:
      containers:
        - name: grafana-alloy
          image: grafana/alloy:latest
          args:
            - run
            - /etc/alloy/alloy.hcl
          env:
            - name: LOKI_USERNAME
              valueFrom:
                secretKeyRef:
                  name: loki-credentials
                  key: username
            - name: LOKI_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: loki-credentials
                  key: password
            - name: LOG_LEVEL
              value: "debug"
          volumeMounts:
            - name: config
              mountPath: /etc/alloy
            - name: containers
              mountPath: /var/log/containers
              readOnly: true
            - name: pods
              mountPath: /var/log/pods
              readOnly: true
            - name: docker-containers
              mountPath: /var/lib/docker/containers
              readOnly: true
      volumes:
        - name: config
          configMap:
            name: alloy-config
        - name: containers
          hostPath:
            path: /var/log/containers
            type: Directory
        - name: pods
          hostPath:
            path: /var/log/pods
            type: Directory
        - name: docker-containers
          hostPath:
            path: /var/lib/docker/containers
            type: Directory


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/datadog-agent.yaml
================================================================================
apiVersion: datadoghq.com/v2alpha1
kind: DatadogAgent
metadata:
  name: datadog
spec:
  features:
    logCollection:
      enabled: true
      containerCollectAll: true
    apm:
      enabled: true
      unixDomainSocketConfig:
        path: /var/run/datadog/apm.socket
    admissionController:
      enabled: true
      mutateUnlabelled: false
  global:
    clusterName: docker-desktop
    credentials:
      apiSecret:
        secretName: datadog-secret
        keyName: api-key
      appSecret:
        secretName: datadog-secret
        keyName: app-key
  override:
    nodeAgent:
      env:
        - name: DD_KUBELET_TLS_VERIFY
          value: "false"


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/client-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: client
  template:
    metadata:
      labels:
        app: client
        admission.datadoghq.com/enabled: "true"
      annotations:
        admission.datadoghq.com/js-lib.version: "v5.45.0"
    spec:
      containers:
        - name: client
          image: luketchang/client
          env:
            - name: NODE_OPTIONS
              value: "--openssl-legacy-provider"

---
apiVersion: v1
kind: Service
metadata:
  name: client-srv
spec:
  type: ClusterIP
  selector:
    app: client
  ports:
    - name: client
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: loki-credentials
  namespace: default
type: Opaque
data:
  username: MTEzNTg5Mw== # Base64-encoded "1135893"
  password: Z2xjX2V5SnZJam9pTVRNMU5UY3lNeUlzSW00aU9pSnpkR0ZqYXkweE1UYzRNRGswTFdoc0xYSmxZV1F0WVd4c0lpd2lheUk2SW5Cbk1EUkVhWE5UV0hKc1RqWTJVREpqTWxFME1XbzJNU0lzSW0waU9uc2ljaUk2SW5CeWIyUXRkWE10ZDJWemRDMHdJbjE5 # Base64-encoded secret


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/services-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
  namespace: default
type: Opaque
data:
  JWT_KEY: c29tZS1zZWNyZXQta2V5 # Base64-encoded "some-secret-key"

---
apiVersion: v1
kind: Secret
metadata:
  name: stripe-secret
  namespace: default
type: Opaque
data:
  STRIPE_KEY: c2tfdGVzdF81MVF1MXEwR0xPYkNabzh6bVhhVEt1ajZLSEtVdVQ1WVJLU3NOcHJNa3RYbVBHeU9UNllYb2ZSS0d5TkNNaTdCN0wxZjFIYnR4WHppS0ZlSDBZSFU1S3JRTTAwYjIzV09iYXQ= # Base64-encoded secret key


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-config.yaml
================================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
  namespace: default
data:
  alloy.hcl: |
    discovery.kubernetes "pod" {
      role = "pod"
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pod.targets

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex = "auth|payments|orders|tickets|expiration"
        action = "replace"
        target_label = "app_group"
        replacement = "application"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action = "replace"
        target_label = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action = "replace"
        target_label = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        action = "replace"
        target_label = "app"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "job"
        separator = "/"
        replacement = "$1"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "__path__"
        separator = "/"
        replacement = "/var/log/pods/*$1/*.log"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_id"]
        action = "replace"
        target_label = "container_runtime"
        regex = "^(\\S+):\\/\\/.+$"
        replacement = "$1"
      }
    }

    loki.source.kubernetes "pod_logs" {
      targets    = discovery.relabel.pod_logs.output
      forward_to = [loki.process.pod_logs.receiver]
    }

    loki.process "pod_logs" {
      stage.static_labels {
          values = {
            cluster = "docker-desktop",
          }
      }
      forward_to = [loki.write.default.receiver]
    }

    loki.write "default" {
      endpoint {
        url = "https://logs-prod-021.grafana.net/loki/api/v1/push"
        basic_auth {
          username = sys.env("LOKI_USERNAME")
          password = sys.env("LOKI_PASSWORD")
        }
      }
    }


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/expiration-redis-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
    name: expiration-redis-depl
spec:
    replicas: 1
    selector:
        matchLabels:
            app: expiration-redis
    template:
        metadata:
            labels:
                app: expiration-redis
        spec:
            containers:
                - name: expiration-redis
                  image: redis
---
apiVersion: v1
kind: Service
metadata:
    name: expiration-redis-srv
spec:
    type: ClusterIP
    selector:
        app: expiration-redis
    ports:
        - name: db
          protocol: TCP
          port: 6379
          targetPort: 6379

================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/ingress-srv.yaml
================================================================================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-service
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/use-regex: 'true'
spec:
  rules:
    - host: ticketing.dev
      http:
        paths:
          - path: /api/payments/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: payments-srv
                port:
                  number: 3000
          - path: /api/users/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: auth-srv
                port:
                  number: 3000
          - path: /api/tickets/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: tickets-srv
                port:
                  number: 3000
          - path: /api/orders/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: orders-srv
                port:
                  number: 3000
          - path: /?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: client-srv
                port:
                  number: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/auth-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: auth
  template:
    metadata:
      labels:
        app: auth
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: auth
          image: luketchang/auth
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: AUTH_MONGO_URI
              value: "mongodb://auth-mongo-srv:27017/auth"
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: auth-srv
spec:
  type: ClusterIP
  selector:
    app: auth
  ports:
    - name: auth
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/auth-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: auth-mongo
  template:
    metadata:
      labels:
        app: auth-mongo
    spec:
      containers:
        - name: auth-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: auth-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: auth-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/tickets-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tickets-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tickets
  template:
    metadata:
      labels:
        app: tickets
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: tickets
          image: luketchang/tickets
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: TICKETS_MONGO_URI
              value: "mongodb://tickets-mongo-srv:27017/tickets"
            - name: NATS_URL
              value: "nats://nats-srv:4222"
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: tickets-srv
spec:
  type: ClusterIP
  selector:
    app: tickets
  ports:
    - name: tickets
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/payments-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payments-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payments
  template:
    metadata:
      labels:
        app: payments
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: payments
          image: luketchang/payments
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: PAYMENTS_MONGO_URI
              value: "mongodb://payments-mongo-srv:27017/payments"
            - name: NATS_URL
              value: "nats://nats-srv:4222"
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY
            - name: STRIPE_KEY
              valueFrom:
                secretKeyRef:
                  name: stripe-secret
                  key: STRIPE_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: payments-srv
spec:
  type: ClusterIP
  selector:
    app: payments
  ports:
    - name: payments
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/datadog-agent-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: datadog-secret
type: Opaque
data:
  api-key: YTVjOTU1ZDMxY2Q3NTY1YTNkMGViZGI3Y2QzYTc4NzA=
  app-key: YjcyZmY0NDI5MzhkMzBkNjFmYmJlMmEzNTk4MGZkMTcwZTg4ODUxNQ==


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/orders-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orders-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orders
  template:
    metadata:
      labels:
        app: orders
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: orders
          image: luketchang/orders
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: ORDERS_MONGO_URI
              value: "mongodb://orders-mongo-srv:27017/orders"
            - name: NATS_URL
              value: "nats://nats-srv:4222"
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: orders-srv
spec:
  type: ClusterIP
  selector:
    app: orders
  ports:
    - name: orders
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/expiration-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: expiration-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: expiration
  template:
    metadata:
      labels:
        app: expiration
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: expiration
          image: luketchang/expiration
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: NATS_URL
              value: "nats://nats-srv:4222"
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: REDIS_HOST
              value: expiration-redis-srv


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-rbac.yaml
================================================================================
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: alloy-logs
rules:
  - apiGroups: [""]
    resources: ["pods", "pods/log"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: alloy-logs-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: alloy-logs
subjects:
  - kind: ServiceAccount
    name: default
    namespace: default


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/payments-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payments-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payments-mongo
  template:
    metadata:
      labels:
        app: payments-mongo
    spec:
      containers:
        - name: payments-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: payments-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: payments-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer;


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError } from '@lt-ticketing/common';

import { currentUserRouter } from './routes/currentuser';
import { signinRouter } from './routes/signin';
import { signoutRouter } from './routes/signout';
import { signupRouter } from './routes/signup';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);

app.use(currentUserRouter);
app.use(signinRouter);
app.use(signoutRouter);
app.use(signupRouter);
app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) {
    throw new Error("JWT_KEY not defined.");
  }
  if (!process.env.AUTH_MONGO_URI) {
    throw new Error("JWT_KEY not defined.");
  }

  try {
    await mongoose.connect(process.env.AUTH_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");
  } catch (err) {
    logger.error(err);
  }

  app.listen(3000, () => {
    logger.info("Listening on port 3000!");
  });
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/test/getAuthCookie.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const getAuthCookie = async () => {
    const email = 'test@test.com';
    const password = 'password';

    const res = await request(app)
        .post('/api/users/signup')
        .send({
            email,
            password
        })
        .expect(201);

    return res.get('Set-Cookie');
};

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from 'mongodb-memory-server';
import mongoose from 'mongoose';

let mongo: any;
beforeAll(async () => {
    process.env.JWT_KEY = 'JWT_TEST_KEY';
    
    mongo = new MongoMemoryServer();
    const mongoUri = await mongo.getUri();

    await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true
    });
});

beforeEach(async () => {
    const collections = await mongoose.connection.db.collections();

    for(let collection of collections) {
        await collection.deleteMany({});
    }
});

afterAll(async () => {
    await mongo.stop();
    await mongoose.connection.close();
});

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/utils/password.ts
================================================================================
import { scrypt, randomBytes } from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(scrypt);

export class Password {
    static async hashPassword(password: string) {
        const salt = randomBytes(8).toString('hex');
        const buf = (await scryptAsync(password, salt, 64)) as Buffer;

        return `${buf.toString('hex')}.${salt}`;
    }

    static async comparePasswords(storedPassword: string, suppliedPassword: string) {
        const [hashedPassword, salt] = storedPassword.split('.');
        const buf = (await scryptAsync(suppliedPassword, salt, 64)) as Buffer;
        
        return buf.toString('hex') === hashedPassword;
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/models/user.ts
================================================================================
import mongoose, { Schema } from 'mongoose';
import { Password } from '../utils/password';

interface UserAttrs {
    email: string;
    password: string;
}

interface UserDoc extends mongoose.Document {
   email: string;
   password: string; 
}

interface UserModel extends mongoose.Model<UserDoc> {
    build(attrs: UserAttrs): UserDoc;
}

const userSchema = new Schema(
    {
        email: {
            type: String,
            required: true
        },
        password: {
            type: String,
            required: true
        }
    }, {
        toJSON: {
            transform(_, ret) {
                ret.id = ret._id;
                delete ret._id;
                delete ret.password;
                delete ret.__v;
            }
        }
    }
);

userSchema.pre('save', async function() {
    if(this.isModified('password')) {
        const hashed = await Password.hashPassword(this.get('password'));
        this.set('password', hashed);
    }
});

userSchema.statics.build = (attrs: UserAttrs) => {
    return new User(attrs);
}

const User = mongoose.model<UserDoc, UserModel>('User', userSchema);

export { User };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signout.ts
================================================================================
import express from "express";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post("/api/users/signout", (req, res) => {
  const sessionId = req.session?.id;
  const sessionEmail = req.session?.email;

  logger.info("Received sign out request", { sessionEmail, sessionId });
  req.session = null;

  logger.info("User signed out", { sessionEmail, sessionId });
  res.send("Signed out.");
});

export { router as signoutRouter };


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/currentuser.ts
================================================================================
import express from "express";
import { currentUser } from "@lt-ticketing/common";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get("/api/users/currentuser", currentUser, (req, res) => {
  logger.info("Handling request for current user", {
    currentUser: req.currentUser,
  });
  res.send({ currentUser: req.currentUser || null });
});

export { router as currentUserRouter };


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signin.ts
================================================================================
import express, { Request, Response } from 'express';
import { body } from 'express-validator';
import jwt from 'jsonwebtoken';
import { validateRequest, BadRequestError } from '@lt-ticketing/common';
import { User } from '../models/user'; 
import { Password } from '../utils/password';
import { logger } from '@lt-ticketing/common';

const router = express.Router();

router.post(
    '/api/users/signin', 
    [
        body('email')
            .isEmail()
            .withMessage('Please enter valid email.'),
        body('password')
            .trim()
            .notEmpty()
            .withMessage('Must supply a password')
    ],
    validateRequest,
    async (req: Request, res: Response) => {
        const { email, password } = req.body;
        logger.info('Received sign in request', { email });
        

        const existingUser = await User.findOne({ email });
        if(!existingUser) {
            logger.warn('User not found', { email });
            throw new BadRequestError('Invalid email.');
        }

        logger.info('User found', { email, userId: existingUser.id });
        const passwordsMatch = await Password.comparePasswords(existingUser.password, password);
        if(!passwordsMatch) {
            logger.warn('Invalid password', { email, userId: existingUser.id });
            throw new BadRequestError('Invalid password.')
        }

        logger.info('Password matches', { email, userId: existingUser.id });
        const userJwt = jwt.sign(
            {
                id: existingUser.id,
                email: existingUser.email
            }, 
            process.env.JWT_KEY!
        );

        req.session = {
            email,
            jwt: userJwt
        };

        logger.info('User signed in', { email, userId: existingUser.id });
        res.status(200).send(existingUser);
    }
);

export { router as signinRouter };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signup.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { User } from "../models/user";
import jwt from "jsonwebtoken";
import { validateRequest, BadRequestError } from "@lt-ticketing/common";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/users/signup",
  [
    body("email").isEmail().withMessage("Please enter valid email."),
    body("password")
      .trim()
      .isLength({ min: 4, max: 20 })
      .withMessage("Password must be between 4 and 20 characters."),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { email, password } = req.body;

    logger.info("Received sign up request", { email });

    const userExists = await User.findOne({ email });
    if (userExists) {
      logger.warn("Email already in use", { email });
      throw new BadRequestError("Email already in use.");
    }

    const newUser = User.build({ email, password });
    await newUser.save();

    logger.info("User created", { email, userId: newUser.id });
    const userJwt = jwt.sign(
      {
        id: newUser.id,
        email: newUser.email,
      },
      process.env.JWT_KEY!
    );

    req.session = {
      jwt: userJwt,
    };

    logger.info("User signed up", { email, userId: newUser.id });
    res.status(201).send(newUser);
  }
);

export { router as signupRouter };


================================================================================
File: /Users/luketchang/code/ticketing/common/build/tracing.d.ts
================================================================================
import { Span } from "@opentelemetry/api";
export declare const tracer: import("@opentelemetry/api").Tracer;
export declare const setupTracing: (serviceName: string) => void;
export declare const createMessageProducerSpan: (exchange: string, routingKey: string, messageId: string) => Span;
export declare const createMessageConsumerSpan: (exchange: string, routingKey: string, queue: string, messageId: string) => Span;
export declare const traceMessageProcessing: <T>(span: Span, processFn: () => Promise<T>) => Promise<T>;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/mcp-server.d.ts
================================================================================
export {};


================================================================================
File: /Users/luketchang/code/ticketing/common/build/logger.d.ts
================================================================================
import winston from "winston";
declare const logger: winston.Logger;
export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/common/build/index.d.ts
================================================================================
export * from "./errors/bad-request-error";
export * from "./errors/custom-error";
export * from "./errors/database-connection-error";
export * from "./errors/not-authorized-error";
export * from "./errors/not-found-error";
export * from "./errors/request-validation-error";
export * from "./middlewares/current-user";
export * from "./middlewares/error-handler";
export * from "./middlewares/require-auth";
export * from "./middlewares/validate-request";
export * from "./events/subject";
export * from "./events/base-event";
export * from "./events/base-publisher";
export * from "./events/base-listener";
export * from "./events/ticket-created-event";
export * from "./events/ticket-updated-event";
export * from "./events/order-created-event";
export * from "./events/order-cancelled-event";
export * from "./events/types/order-status";
export * from "./events/types/queue-group-names";
export * from "./events/expiration-complete-event";
export * from "./events/payment-created-event";
export * from "./messaging/rabbitmq-wrapper";
export { Publisher as RabbitMQPublisher } from "./messaging/base-publisher";
export { Listener as RabbitMQListener } from "./messaging/base-listener";
export * from "./tracing";
export { logger } from "./logger";
export * from "./mcp-server";


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/current-user.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
interface UserPayload {
    id: string;
    email: string;
}
declare global {
    namespace Express {
        interface Request {
            currentUser?: UserPayload;
        }
    }
}
export declare const currentUser: (req: Request, res: Response, next: NextFunction) => void;
export {};


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/require-auth.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const requireAuth: (req: Request, res: Response, next: NextFunction) => void;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/validate-request.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const validateRequest: (req: Request, res: Response, next: NextFunction) => void;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/error-handler.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const errorHandler: (err: Error, req: Request, res: Response, next: NextFunction) => Response<any> | undefined;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/not-found-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class NotFoundError extends CustomError {
    constructor();
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/request-validation-error.d.ts
================================================================================
import { ValidationError } from 'express-validator';
import { CustomError } from './custom-error';
export declare class RequestValidationError extends CustomError {
    errors: ValidationError[];
    constructor(errors: ValidationError[]);
    statusCode: number;
    serializeErrors(): {
        message: any;
        field: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/bad-request-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class BadRequestError extends CustomError {
    message: string;
    constructor(message: string);
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/not-authorized-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class NotAuthorizedError extends CustomError {
    constructor();
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/database-connection-error.d.ts
================================================================================
import { CustomError } from "./custom-error";
export declare class DatabaseConnectionError extends CustomError {
    constructor();
    statusCode: number;
    reason: string;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/custom-error.d.ts
================================================================================
export declare abstract class CustomError extends Error {
    abstract statusCode: number;
    abstract serializeErrors(): {
        message: string;
        field?: string;
    }[];
    constructor(message: string);
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/ticket-updated-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface TicketUpdatedEvent extends Event {
    subject: Subject.TicketUpdated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
        orderId?: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/order-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';
export interface OrderCreatedEvent extends Event {
    subject: Subject.OrderCreated;
    data: {
        id: string;
        status: OrderStatus;
        userId: string;
        expiresAt: string;
        version: number;
        ticket: {
            id: string;
            price: number;
        };
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/order-cancelled-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface OrderCancelledEvent extends Event {
    subject: Subject.OrderCancelled;
    data: {
        id: string;
        version: number;
        ticket: {
            id: string;
        };
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/payment-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface PaymentCreatedEvent extends Event {
    subject: Subject.PaymentCreated;
    data: {
        id: string;
        orderId: string;
        stripeId: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/ticket-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface TicketCreatedEvent extends Event {
    subject: Subject.TicketCreated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/expiration-complete-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface ExpirationCompleteEvent extends Event {
    subject: Subject.ExpirationComplete;
    data: {
        orderId: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-publisher.d.ts
================================================================================
import { Stan } from "node-nats-streaming";
import { Event } from "./base-event";
export declare abstract class Publisher<T extends Event> {
    abstract subject: T["subject"];
    protected client: Stan;
    constructor(client: Stan);
    publish(data: T["data"]): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-listener.d.ts
================================================================================
import { Message, Stan } from "node-nats-streaming";
import { Event } from "./base-event";
export declare abstract class Listener<T extends Event> {
    abstract subject: T["subject"];
    abstract queueGroupName: string;
    abstract onMessage(data: T["data"], msg: Message): void;
    protected client: Stan;
    protected ackWait: number;
    constructor(client: Stan);
    subscriptionOptions(): import("node-nats-streaming").SubscriptionOptions;
    listen(): void;
    parseMessage(msg: Message): any;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/subject.d.ts
================================================================================
export declare enum Subject {
    TicketCreated = "ticket:created",
    TicketUpdated = "ticket:updated",
    OrderCreated = "order:created",
    OrderCancelled = "order:cancelled",
    ExpirationComplete = "expiration:complete",
    PaymentCreated = "payment:created"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-event.d.ts
================================================================================
import { Subject } from './subject';
export interface Event {
    subject: Subject;
    data: any;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/types/order-status.d.ts
================================================================================
export declare enum OrderStatus {
    Created = "created",
    Cancelled = "cancelled",
    AwaitingPayment = "awaiting:payment",
    Complete = "complete"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/types/queue-group-names.d.ts
================================================================================
export declare enum QueueGroupName {
    OrdersService = "orders-service",
    TicketsService = "tickets-service",
    PaymentsService = "payments-service",
    ExpirationService = "expiration-service"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/rabbitmq-wrapper.d.ts
================================================================================
import * as amqplib from "amqplib";
export interface RabbitMQConfig {
    url: string;
    exchanges: ExchangeConfig[];
}
export interface ExchangeConfig {
    name: string;
    type: string;
    options?: amqplib.Options.AssertExchange;
}
export declare class RabbitMQWrapper {
    private _connection?;
    private _channel?;
    private _config;
    private _initialized;
    constructor(config: RabbitMQConfig);
    get channel(): amqplib.Channel;
    get connection(): amqplib.Connection;
    get isInitialized(): boolean;
    connect(): Promise<void>;
    close(): Promise<void>;
}
export declare const defaultRabbitMQConfig: RabbitMQConfig;
export declare const rabbitmqWrapper: RabbitMQWrapper;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/base-publisher.d.ts
================================================================================
import { Channel } from "amqplib";
import { Event } from "../events/base-event";
export declare abstract class Publisher<T extends Event> {
    abstract routingKey: T["subject"];
    protected channel: Channel;
    protected exchange: string;
    constructor(channel: Channel, exchange?: string);
    publish(data: T["data"]): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/base-listener.d.ts
================================================================================
import { Channel, ConsumeMessage } from "amqplib";
import { Event } from "../events/base-event";
export declare abstract class Listener<T extends Event> {
    abstract routingKey: T["subject"];
    abstract queueName: string;
    abstract onMessage(data: T["data"], msg: ConsumeMessage): Promise<void>;
    protected channel: Channel;
    protected exchange: string;
    constructor(channel: Channel, exchange?: string);
    listen(): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/__mocks__/rabbitmq-wrapper.d.ts
================================================================================
export declare const rabbitmqWrapper: {
    channel: {
        publish: any;
        consume: any;
        ack: any;
        nack: any;
        assertQueue: any;
        bindQueue: any;
        assertExchange: any;
        prefetch: any;
    };
    connection: {
        createChannel: any;
        close: any;
    };
    connect: any;
    close: any;
    isInitialized: boolean;
};


================================================================================
File: /Users/luketchang/code/ticketing/common/src/logger.ts
================================================================================
import winston from "winston";

const serviceName = process.env.SERVICE_NAME || "common";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: serviceName },
  transports: [new winston.transports.Console()],
});

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/common/src/index.ts
================================================================================
export * from "./errors/bad-request-error";
export * from "./errors/custom-error";
export * from "./errors/database-connection-error";
export * from "./errors/not-authorized-error";
export * from "./errors/not-found-error";
export * from "./errors/request-validation-error";

export * from "./middlewares/current-user";
export * from "./middlewares/error-handler";
export * from "./middlewares/require-auth";
export * from "./middlewares/validate-request";

export * from "./events/subject";
export * from "./events/base-event";
export * from "./events/base-publisher";
export * from "./events/base-listener";
export * from "./events/ticket-created-event";
export * from "./events/ticket-updated-event";
export * from "./events/order-created-event";
export * from "./events/order-cancelled-event";
export * from "./events/types/order-status";
export * from "./events/types/queue-group-names";
export * from "./events/expiration-complete-event";
export * from "./events/payment-created-event";

export { logger } from "./logger";


================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/require-auth.ts
================================================================================
import { Request, Response, NextFunction } from 'express';

import { NotAuthorizedError } from '../errors/not-authorized-error';

export const requireAuth = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    if(!req.currentUser) {
        throw new NotAuthorizedError();
    }

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/validate-request.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';

import { RequestValidationError } from '../errors/request-validation-error';

export const validateRequest = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const errors = validationResult(req); 
    if(!errors.isEmpty()) {
        throw new RequestValidationError(errors.array());
    }

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/error-handler.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../errors/custom-error';

export const errorHandler = (
    err: Error, 
    req: Request, 
    res: Response, 
    next: NextFunction
) => {
    if(err instanceof CustomError) {
        return res.status(err.statusCode).send({ errors: err.serializeErrors() });
    }

    console.error(err);
    res.status(400).send({
        errors: [{ message: 'Something went wrong.' }]
    });
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/current-user.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    id: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            currentUser?: UserPayload;
        }
    }
}

export const currentUser = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    if(!req.session?.jwt) {
        return next();
    }

    try {
        const payload = jwt.verify(req.session.jwt, process.env.JWT_KEY!) as UserPayload;
        req.currentUser = payload;
    } catch(_) {}

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/bad-request-error.ts
================================================================================
import { CustomError } from './custom-error';

export class BadRequestError extends CustomError {
    constructor(public message: string) {
        super(message);
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }

    statusCode = 400;
    serializeErrors() {
        return [
            { message: this.message }
        ]
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/database-connection-error.ts
================================================================================
import { CustomError } from "./custom-error";

export class DatabaseConnectionError extends CustomError {
    constructor() {
        super('Database Connection Error');
        Object.setPrototypeOf(this, DatabaseConnectionError.prototype)
    }

    statusCode = 500;
    reason = 'Error connecting to database.';
    serializeErrors() {
        return [
            { message: this.reason }
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/not-authorized-error.ts
================================================================================
import { CustomError } from './custom-error';

export class NotAuthorizedError extends CustomError {
    constructor() {
        super('Not authorized.');
        Object.setPrototypeOf(this, NotAuthorizedError.prototype);
    }

    statusCode = 401;
    serializeErrors() {
        return [
            { message: 'User not authorized.' }
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/request-validation-error.ts
================================================================================
import { ValidationError } from 'express-validator';
import { CustomError } from './custom-error';

export class RequestValidationError extends CustomError {
    constructor(public errors: ValidationError[]) {
        super('Request Validation Error');
        Object.setPrototypeOf(this, RequestValidationError.prototype);
    }

    statusCode = 400;
    serializeErrors() {
        return this.errors.map(err => {
            return {
                message: err.msg,
                field: err.param
            }
        });
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/custom-error.ts
================================================================================
export abstract class CustomError extends Error {
    abstract statusCode: number;
    abstract serializeErrors(): { message: string, field?: string }[];

    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, CustomError.prototype);
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/not-found-error.ts
================================================================================
import { CustomError } from './custom-error';

export class NotFoundError extends CustomError {
    constructor() {
        super('Not Found Error');
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }

    statusCode = 404;
    serializeErrors() {
        return [
            { message: 'Not found.'}
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/payment-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface PaymentCreatedEvent extends Event {
    subject: Subject.PaymentCreated;
    data: {
        id: string;
        orderId: string;
        stripeId: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/order-cancelled-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface OrderCancelledEvent extends Event {
    subject: Subject.OrderCancelled;
    data: {
        id: string;
        version: number;
        ticket: {
            id: string;
        };
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-publisher.ts
================================================================================
import { Stan } from "node-nats-streaming";
import { Event } from "./base-event";
import { logger } from "../logger";

export abstract class Publisher<T extends Event> {
  abstract subject: T["subject"];
  protected client: Stan;

  constructor(client: Stan) {
    this.client = client;
  }

  publish(data: T["data"]): Promise<void> {
    return new Promise((resolve, reject) => {
      this.client.publish(this.subject, JSON.stringify(data), (err) => {
        if (err) {
          logger.error("Error publishing event", {
            subject: this.subject,
            error: err,
          });
          return reject(err);
        }

        logger.info("Event published", { subject: this.subject, data });
        resolve();
      });
    });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-event.ts
================================================================================
import { Subject } from './subject';

export interface Event {
    subject: Subject;
    data: any;
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/expiration-complete-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface ExpirationCompleteEvent extends Event {
    subject: Subject.ExpirationComplete;
    data: {
        orderId: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/ticket-updated-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface TicketUpdatedEvent extends Event {
    subject: Subject.TicketUpdated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
        orderId?: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/subject.ts
================================================================================
export enum Subject {
    TicketCreated = 'ticket:created',
    TicketUpdated = 'ticket:updated',

    OrderCreated = 'order:created',
    OrderCancelled = 'order:cancelled',

    ExpirationComplete = 'expiration:complete',

    PaymentCreated = 'payment:created'
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-listener.ts
================================================================================
import { Message, Stan } from "node-nats-streaming";
import { Event } from "./base-event";
import { logger } from "../logger";

export abstract class Listener<T extends Event> {
  abstract subject: T["subject"];
  abstract queueGroupName: string;
  abstract onMessage(data: T["data"], msg: Message): void;
  protected client: Stan;
  protected ackWait = 5 * 1000;

  constructor(client: Stan) {
    this.client = client;
  }

  subscriptionOptions() {
    return this.client
      .subscriptionOptions()
      .setDeliverAllAvailable()
      .setManualAckMode(true)
      .setAckWait(this.ackWait)
      .setDurableName(this.queueGroupName);
  }

  listen() {
    const subscription = this.client.subscribe(
      this.subject,
      this.queueGroupName,
      this.subscriptionOptions()
    );

    subscription.on("message", (msg: Message) => {
      logger.info(
        `Message received: ${this.subject} / ${this.queueGroupName}`,
        { subject: this.subject, queueGroupName: this.queueGroupName }
      );

      const parsedData = this.parseMessage(msg);
      this.onMessage(parsedData, msg);
    });
  }

  parseMessage(msg: Message) {
    const data = msg.getData();
    return typeof data === "string"
      ? JSON.parse(data)
      : JSON.parse(data.toString("utf8"));
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/ticket-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface TicketCreatedEvent extends Event {
    subject: Subject.TicketCreated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/order-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface OrderCreatedEvent extends Event {
    subject: Subject.OrderCreated;
    data: {
        id: string;
        status: OrderStatus;
        userId: string;
        expiresAt: string;
        version: number;
        ticket: {
            id: string;
            price: number;
        };
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/types/order-status.ts
================================================================================
export enum OrderStatus {
    Created = 'created',
    Cancelled = 'cancelled', //catch all
    AwaitingPayment = 'awaiting:payment',
    Complete = 'complete'
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/types/queue-group-names.ts
================================================================================
export enum QueueGroupName {
    OrdersService = 'orders-service',
    TicketsService = 'tickets-service',
    PaymentsService = 'payments-service',
    ExpirationService = 'expiration-service'
}

================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer; 

================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "expiration" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/index.ts
================================================================================
import "./tracer";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { natsWrapper } from "./nats-wrapper";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.NATS_CLIENT_ID)
    throw new Error("NATS_CLIENT_ID not defined.");
  if (!process.env.NATS_CLUSTER_ID)
    throw new Error("NATS_CLUSTER_ID not defined.");
  if (!process.env.NATS_URL) throw new Error("NATS_URL not defined.");

  try {
    await natsWrapper.connect(
      process.env.NATS_CLUSTER_ID,
      process.env.NATS_CLIENT_ID,
      process.env.NATS_URL
    );

    logger.info("Connected to NATS", {
      clientId: process.env.NATS_CLIENT_ID,
      clusterId: process.env.NATS_CLUSTER_ID,
      url: process.env.NATS_URL,
    });

    natsWrapper.client.on("close", () => {
      logger.warn("NATS connection closed!");
      process.exit();
    });
    process.on("SIGINT", () => natsWrapper.client.close());
    process.on("SIGTERM", () => natsWrapper.client.close());

    new OrderCreatedListener(natsWrapper.client).listen();
  } catch (err) {
    logger.error("Error starting the application", { error: err });
  }
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/queues/expiration-queue.ts
================================================================================
import Queue from "bull";

import { natsWrapper } from "../nats-wrapper";
import { ExpirationCompletePublisher } from "../events/publishers/expiration-complete-publisher";
import { logger } from "@lt-ticketing/common";

interface Payload {
  orderId: string;
}

const expirationQueue = new Queue<Payload>("order:expiration", {
  redis: {
    host: process.env.REDIS_HOST,
  },
});

expirationQueue.process(async (job) => {
  logger.info(
    `Publishing expiration:complete event for orderId ${job.data.orderId}`
  );
  await new ExpirationCompletePublisher(natsWrapper.client).publish({
    orderId: job.data.orderId,
  });
});

export { expirationQueue };


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/events/publishers/expiration-complete-publisher.ts
================================================================================
import { Publisher, ExpirationCompleteEvent, Subject } from '@lt-ticketing/common';

export class ExpirationCompletePublisher extends Publisher<ExpirationCompleteEvent> {
    subject: Subject.ExpirationComplete = Subject.ExpirationComplete;
}

================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/events/listeners/order-created-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Listener,
  OrderCreatedEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { expirationQueue } from "../../queues/expiration-queue";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  subject: Subject.OrderCreated = Subject.OrderCreated;
  queueGroupName = QueueGroupName.ExpirationService;

  async onMessage(data: OrderCreatedEvent["data"], msg: Message) {
    logger.info("Order created event received", { data });
    const delay = new Date(data.expiresAt).getTime() - new Date().getTime();

    logger.info("Order expires in milliseconds.", { delay, data });
    await expirationQueue.add(
      {
        orderId: data.id,
      },
      {
        delay,
      }
    );

    logger.info("Order added to expiration queue", { data });

    msg.ack();

    logger.info("Order created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer; 

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';

import { indexOrderRouter } from './routes/index';
import { newOrderRouter } from './routes/new';
import { showOrderRouter } from './routes/show';
import { deleteOrderRouter } from './routes/delete';


const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(indexOrderRouter);
app.use(newOrderRouter);
app.use(showOrderRouter);
app.use(deleteOrderRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "orders" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { natsWrapper } from "./nats-wrapper";
import { TicketCreatedListener } from "./events/listeners/ticket-created-listener";
import { TicketUpdatedListener } from "./events/listeners/ticket-updated-listener";
import { ExpirationCompleteListener } from "./events/listeners/expiration-complete-listener";
import { PaymentCreatedListener } from "./events/listeners/payment-created-listener";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.ORDERS_MONGO_URI)
    throw new Error("TICKETS_MONGO_URI not defined.");
  if (!process.env.NATS_CLIENT_ID)
    throw new Error("NATS_CLIENT_ID not defined.");
  if (!process.env.NATS_CLUSTER_ID)
    throw new Error("NATS_CLUSTER_ID not defined.");
  if (!process.env.NATS_URL) throw new Error("NATS_URL not defined.");

  try {
    await natsWrapper.connect(
      process.env.NATS_CLUSTER_ID,
      process.env.NATS_CLIENT_ID,
      process.env.NATS_URL
    );

    natsWrapper.client.on("close", () => {
      logger.info("NATS connection closed!");
      process.exit();
    });
    process.on("SIGINT", () => natsWrapper.client.close());
    process.on("SIGTERM", () => natsWrapper.client.close());

    new TicketCreatedListener(natsWrapper.client).listen();
    new TicketUpdatedListener(natsWrapper.client).listen();
    new ExpirationCompleteListener(natsWrapper.client).listen();
    new PaymentCreatedListener(natsWrapper.client).listen();

    await mongoose.connect(process.env.ORDERS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");
  } catch (err) {
    logger.error(err);
  }

  app.listen(3000, () => {
    logger.info("Listening on port 3000!");
  });
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = () => {
    const id = mongoose.Types.ObjectId().toHexString();
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/createOrder.ts
================================================================================
import request from 'supertest';
import { app } from '../app';
import { TicketDoc } from '../models/ticket'

export const createOrder = async (ticket: TicketDoc, cookie: string[]) => {
    const res = await request(app)
        .post('/api/orders')
        .set('Cookie', cookie)
        .send({ ticketId: ticket.id })
        .expect(201);
    
    return res;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from 'mongodb-memory-server';
import mongoose from 'mongoose';

jest.mock('../nats-wrapper');

let mongo: any;
beforeAll(async () => {
    process.env.JWT_KEY = 'JWT_TEST_KEY';
    
    mongo = new MongoMemoryServer();
    const mongoUri = await mongo.getUri();

    await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true
    });
});

beforeEach(async () => {
    jest.clearAllMocks();
    const collections = await mongoose.connection.db.collections();
    for(let collection of collections) {
        await collection.deleteMany({});
    }
});

afterAll(async () => {
    await mongo.stop();
    await mongoose.connection.close();
});

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/createTicket.ts
================================================================================
import mongoose from 'mongoose';
import { Ticket } from '../models/ticket';

export const createTicket = async () => {
    const ticket = Ticket.build({
        id: mongoose.Types.ObjectId().toHexString(),
        title: 'concert',
        price: 20
    });
    await ticket.save();
    return ticket;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/models/order.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { TicketDoc } from './ticket';
import { OrderStatus } from '@lt-ticketing/common';

interface OrderAttrs {
    userId: string;
    status: OrderStatus;
    expiresAt: Date;
    ticket: TicketDoc;
}

interface OrderDoc extends mongoose.Document {
    userId: string;
    status: OrderStatus;
    expiresAt: Date;
    version: number;
    ticket: TicketDoc;
}

interface OrderModel extends mongoose.Model<OrderDoc> {
    build(attrs: OrderAttrs): OrderDoc;
}

const orderSchema = new mongoose.Schema ({
    userId: {
        type: String,
        required: true
    },
    status: {
        type: String,
        required: true,
        enum: Object.values(OrderStatus),
        default: OrderStatus.Created
    },
    expiresAt: {
        type: mongoose.Schema.Types.Date,
        required: false
    },
    ticket: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Ticket'
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

orderSchema.set('versionKey', 'version');
orderSchema.plugin(updateIfCurrentPlugin);

orderSchema.statics.build = (attrs: OrderAttrs) => {
    return new Order(attrs);
}

const Order = mongoose.model<OrderDoc, OrderModel>('Order', orderSchema);

export { Order };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/models/ticket.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { Order } from './order';
import { OrderStatus } from '@lt-ticketing/common';
import { idText } from 'typescript';

interface TicketAttrs {
    id: string;
    title: string;
    price: number;
}

export interface TicketDoc extends mongoose.Document {
    title: string;
    price: number;
    version: number;
    isReserved(): Promise<boolean>;
}

interface TicketModel extends mongoose.Model<TicketDoc> {
    build(attrs: TicketAttrs): TicketDoc;
    findByEvent(data: { id: string, version: number}): Promise<TicketDoc | null>
}

const ticketSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true,
        min: 0
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

ticketSchema.set('versionKey', 'version');
ticketSchema.plugin(updateIfCurrentPlugin);

ticketSchema.statics.build = (attrs: TicketAttrs) => {
    return new Ticket({
        _id: attrs.id,
        title: attrs.title,
        price: attrs.price
    });
}

ticketSchema.statics.findByEvent = (data: { id: string, version: number}) => {
    return Ticket.findOne({
        _id: data.id,
        version: data.version - 1
    });
}

ticketSchema.methods.isReserved = async function() {
    const existingOrder = Order.findOne({
        ticket: this as TicketDoc,
        status: {
            $in: [
                OrderStatus.Created,
                OrderStatus.AwaitingPayment,
                OrderStatus.Complete
            ]
        }
    });

    return !existingOrder;
}

const Ticket = mongoose.model<TicketDoc, TicketModel>('Ticket', ticketSchema);

export { Ticket };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/publishers/order-created-publisher.ts
================================================================================
import { Subject, Publisher, OrderCreatedEvent } from '@lt-ticketing/common';

export class OrderCreatedPublisher extends Publisher<OrderCreatedEvent> {
    subject: Subject.OrderCreated = Subject.OrderCreated;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/publishers/order-cancelled-publisher.ts
================================================================================
import { Subject, Publisher, OrderCancelledEvent } from '@lt-ticketing/common';

export class OrderCancelledPublisher extends Publisher<OrderCancelledEvent> {
    subject: Subject.OrderCancelled = Subject.OrderCancelled;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/ticket-updated-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Subject,
  QueueGroupName,
  TicketUpdatedEvent,
  Listener,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { logger } from "@lt-ticketing/common";

export class TicketUpdatedListener extends Listener<TicketUpdatedEvent> {
  subject: Subject.TicketUpdated = Subject.TicketUpdated;
  queueGroupName = QueueGroupName.OrdersService;

  async onMessage(data: TicketUpdatedEvent["data"], msg: Message) {
    logger.info("Ticket updated event received", { data });
    const ticket = await Ticket.findByEvent(data);
    if (!ticket) {
      logger.warn("Ticket not found", { data });
      throw new Error("Ticket not found.");
    }

    const { title, price } = data;
    ticket.set({ title, price });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
    });

    msg.ack();

    logger.info("Ticket updated event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/ticket-created-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Subject,
  QueueGroupName,
  TicketCreatedEvent,
  Listener,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { logger } from "@lt-ticketing/common";

export class TicketCreatedListener extends Listener<TicketCreatedEvent> {
  subject: Subject.TicketCreated = Subject.TicketCreated;
  queueGroupName = QueueGroupName.OrdersService;

  async onMessage(data: TicketCreatedEvent["data"], msg: Message) {
    logger.info("Ticket created event received", { data });
    const { id, title, price } = data;
    const ticket = Ticket.build({ id, title, price });
    await ticket.save();

    logger.info("Ticket created", { data });

    msg.ack();

    logger.info("Ticket created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/expiration-complete-listener.ts
================================================================================
import { Message } from "node-nats-streaming";
import {
  Subject,
  QueueGroupName,
  ExpirationCompleteEvent,
  Listener,
  OrderStatus,
} from "@lt-ticketing/common";
import { OrderCancelledPublisher } from "../publishers/order-cancelled-publisher";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class ExpirationCompleteListener extends Listener<ExpirationCompleteEvent> {
  subject: Subject.ExpirationComplete = Subject.ExpirationComplete;
  queueGroupName = QueueGroupName.OrdersService;

  async onMessage(data: ExpirationCompleteEvent["data"], msg: Message) {
    logger.info("Expiration complete event received", { data });
    const order = await Order.findById(data.orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found.");
    }

    if (order.status === OrderStatus.Complete) {
      logger.info("Order already completed", { data });
      msg.ack();

      logger.info("Expiration complete event acknowledged", { data });
      return;
    }

    order.set({ status: OrderStatus.Cancelled });
    await order.save();

    logger.info("Order cancelled", { data });

    await new OrderCancelledPublisher(this.client).publish({
      id: order.id,
      version: order.version,
      ticket: {
        id: order.ticket.id,
      },
    });

    logger.info("Order cancellation published", { data });

    msg.ack();

    logger.info("Expiration complete event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/payment-created-listener.ts
================================================================================
import {
  Subject,
  Listener,
  PaymentCreatedEvent,
  QueueGroupName,
  OrderStatus,
} from "@lt-ticketing/common";
import { Message } from "node-nats-streaming";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class PaymentCreatedListener extends Listener<PaymentCreatedEvent> {
  subject: Subject.PaymentCreated = Subject.PaymentCreated;
  queueGroupName = QueueGroupName.OrdersService;

  async onMessage(data: PaymentCreatedEvent["data"], msg: Message) {
    logger.info("Payment created event received", { data });
    const order = await Order.findById(data.orderId);

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found.");
    }

    order.set({ status: OrderStatus.Complete });
    await order.save();

    logger.info("Order completed", { data });

    //TODO: add OrderUpdatedEvent to tell other services to update orders

    msg.ack();

    logger.info("Payment created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/new.ts
================================================================================
import mongoose from "mongoose";
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { Ticket } from "../models/ticket";
import { Order } from "../models/order";
import {
  requireAuth,
  validateRequest,
  NotFoundError,
  OrderStatus,
  BadRequestError,
} from "@lt-ticketing/common";
import { OrderCreatedPublisher } from "../events/publishers/order-created-publisher";
import { natsWrapper } from "../nats-wrapper";
import { logger } from "@lt-ticketing/common";

const EXP_TIME_SEC = 1 * 30;
const router = express.Router();

router.post(
  "/api/orders",
  requireAuth,
  [
    body("ticketId")
      .not()
      .isEmpty()
      .custom((input: string) => mongoose.Types.ObjectId.isValid(input))
      .withMessage("Ticket id must be defined."),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { ticketId } = req.body;
    logger.info("Received order creation request", {
      ticketId,
      userId: req.currentUser!.id,
    });

    const ticket = await Ticket.findById(ticketId);
    if (!ticket) {
      logger.warn("Ticket not found", { ticketId });
      throw new NotFoundError();
    }

    const isReserved = await ticket.isReserved();
    if (isReserved) {
      logger.warn("Ticket already reserved", { ticketId });
      throw new BadRequestError("Ticket already reserved.");
    }

    const expirationTime = new Date();
    expirationTime.setSeconds(expirationTime.getSeconds() + EXP_TIME_SEC);

    const order = Order.build({
      userId: req.currentUser!.id,
      status: OrderStatus.Created,
      expiresAt: expirationTime,
      ticket,
    });
    await order.save();

    logger.info("Order created", { order });

    new OrderCreatedPublisher(natsWrapper.client).publish({
      id: order.id,
      status: order.status,
      userId: order.userId,
      expiresAt: order.expiresAt.toISOString(),
      version: order.version,
      ticket: {
        id: ticket.id,
        price: ticket.price,
      },
    });

    logger.info("Order creation published", { order });

    res.status(201).send(order);
  }
);

export { router as newOrderRouter };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/index.ts
================================================================================
import express, { Request, Response } from 'express';
import { requireAuth } from '@lt-ticketing/common';
import { Order } from '../models/order';

const router = express.Router();

router.get(
    '/api/orders', 
    requireAuth,
    async (req: Request, res: Response) => {
        const orders = await Order.find({
            userId: req.currentUser!.id
        }).populate('ticket');
        
        res.send(orders);
    }
);

export { router as indexOrderRouter };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/show.ts
================================================================================
import express, { Request, Response } from "express";
import {
  NotAuthorizedError,
  NotFoundError,
  requireAuth,
} from "@lt-ticketing/common";
import { Order } from "../models/order";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get(
  "/api/orders/:orderId",
  requireAuth,
  async (req: Request, res: Response) => {
    const { orderId } = req.params;
    logger.info("Received order retrieval request", {
      orderId,
      userId: req.currentUser!.id,
    });

    const order = await Order.findById(orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { order });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to view order", {
        order,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    logger.info("Order retrieved", { order });

    res.send(order);
  }
);

export { router as showOrderRouter };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/delete.ts
================================================================================
import express, { Request, Response } from "express";
import {
  requireAuth,
  OrderStatus,
  NotFoundError,
  NotAuthorizedError,
} from "@lt-ticketing/common";
import { Order } from "../models/order";
import { OrderCancelledPublisher } from "../events/publishers/order-cancelled-publisher";
import { natsWrapper } from "../nats-wrapper";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.delete(
  "/api/orders/:orderId",
  requireAuth,
  async (req: Request, res: Response) => {
    const { orderId } = req.params;
    logger.info("Received order deletion request", {
      orderId,
      userId: req.currentUser!.id,
    });

    const order = await Order.findById(orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { orderId });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to delete order", {
        orderId,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    logger.info("Order cancellation published", { orderId });
    new OrderCancelledPublisher(natsWrapper.client).publish({
      id: order.id,
      version: order.version,
      ticket: {
        id: order.ticket.id,
      },
    });

    logger.info("Order cancelled", { orderId });
    order.status = OrderStatus.Cancelled;
    await order.save();

    res.status(204).send(order);
  }
);

export { router as deleteOrderRouter };