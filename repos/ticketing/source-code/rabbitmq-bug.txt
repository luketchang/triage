================================================================================
File: /Users/luketchang/code/ticketing/skaffold.yaml
================================================================================
apiVersion: skaffold/v2alpha3
kind: Config
deploy:
  kubectl:
    manifests:
      - ./infra/k8s/*
build:
  local:
    push: false
  # googleCloudBuild:
  #   projectId: ticketing-dev-451322
  artifacts:
    - image: luketchang/auth
      context: .
      docker:
        dockerfile: auth/Dockerfile
      sync:
        manual:
          - src: "auth/src/*.ts"
            dest: .
          - src: "auth/src/**/*.ts"
            dest: .
    - image: luketchang/tickets
      context: .
      docker:
        dockerfile: tickets/Dockerfile
      sync:
        manual:
          - src: "tickets/src/*.ts"
            dest: .
          - src: "tickets/src/**/*.ts"
            dest: .
    - image: luketchang/client
      context: client
      docker:
        dockerfile: Dockerfile
      sync:
        manual:
          - src: "src/**/*.js"
            dest: .
    - image: luketchang/orders
      context: .
      docker:
        dockerfile: orders/Dockerfile
      sync:
        manual:
          - src: "orders/src/**/*.ts"
            dest: .
    - image: luketchang/expiration
      context: .
      docker:
        dockerfile: expiration/Dockerfile
      sync:
        manual:
          - src: "expiration/src/**/*.ts"
            dest: .
    - image: luketchang/payments
      context: .
      docker:
        dockerfile: payments/Dockerfile
      sync:
        manual:
          - src: "payments/src/**/*.ts"
            dest: .


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/tracer.ts
================================================================================
import { setupTracing } from "@lt-ticketing/common";

// Initialize OpenTelemetry tracing for this service
setupTracing("tickets-service");


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';

import { indexTicketRouter } from './routes/index';
import { createTicketRouter } from './routes/new';
import { showTicketRouter } from './routes/show';
import { updateTicketRouter } from './routes/update';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(indexTicketRouter);
app.use(createTicketRouter);
app.use(showTicketRouter);
app.use(updateTicketRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/rabbitmq-wrapper.ts
================================================================================
import { RabbitMQWrapper, defaultRabbitMQConfig } from "@lt-ticketing/common";

// Re-export the rabbitmqWrapper instance from common
export const rabbitmqWrapper = new RabbitMQWrapper({
  ...defaultRabbitMQConfig,
  // Override URL if needed
  url: process.env.RABBITMQ_URL || "amqp://guest:guest@rabbitmq-srv:5672",
  // Add any service-specific exchanges if needed
  exchanges: [
    ...defaultRabbitMQConfig.exchanges,
    // Add service-specific exchanges here if needed
  ],
});


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "tickets" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { rabbitmqWrapper } from "./rabbitmq-wrapper";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { OrderCancelledListener } from "./events/listeners/order-cancelled-listener";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.TICKETS_MONGO_URI)
    throw new Error("TICKETS_MONGO_URI not defined.");
  if (!process.env.RABBITMQ_URL) throw new Error("RABBITMQ_URL not defined.");

  try {
    // Connect to RabbitMQ
    await rabbitmqWrapper.connect();
    logger.info("Connected to RabbitMQ", {
      url: process.env.RABBITMQ_URL,
    });

    // Handle graceful shutdown
    process.on("SIGINT", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    process.on("SIGTERM", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    // Initialize listeners
    new OrderCreatedListener(rabbitmqWrapper.channel).listen();
    new OrderCancelledListener(rabbitmqWrapper.channel).listen();

    logger.info("Listeners started");

    // Connect to MongoDB
    await mongoose.connect(process.env.TICKETS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");

    app.listen(3000, () => {
      logger.info("Tickets service listening on port 3000!");
    });
  } catch (err) {
    logger.error("Error during startup", { error: err });
    process.exit(1);
  }
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/__mocks__/rabbitmq-wrapper.ts
================================================================================
// Mock for the RabbitMQ wrapper to be used in tests
export const rabbitmqWrapper = {
  channel: {
    publish: jest.fn().mockImplementation(() => {}),
    assertExchange: jest.fn().mockResolvedValue({}),
    assertQueue: jest.fn().mockResolvedValue({}),
    bindQueue: jest.fn().mockResolvedValue({}),
    consume: jest.fn().mockResolvedValue({}),
    prefetch: jest.fn().mockResolvedValue({}),
    ack: jest.fn().mockImplementation(() => {}),
    nack: jest.fn().mockImplementation(() => {}),
  },
  connect: jest.fn().mockResolvedValue({}),
  close: jest.fn().mockResolvedValue({}),
  isInitialized: true,
};


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = () => {
    const id = mongoose.Types.ObjectId().toHexString();
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from "mongodb-memory-server";
import mongoose from "mongoose";

jest.mock("../rabbitmq-wrapper");

let mongo: any;
beforeAll(async () => {
  process.env.JWT_KEY = "JWT_TEST_KEY";

  mongo = new MongoMemoryServer();
  const mongoUri = await mongo.getUri();

  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

beforeEach(async () => {
  jest.clearAllMocks();
  const collections = await mongoose.connection.db.collections();
  for (let collection of collections) {
    await collection.deleteMany({});
  }
});

afterAll(async () => {
  await mongo.stop();
  await mongoose.connection.close();
});


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/test/createTicket.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const createTicket = async (title: string, price: number, cookie: string[]) => {
    const res = await request(app)
        .post('/api/tickets')
        .set('Cookie', cookie)
        .send({
            title,
            price
        })
        .expect(201);
    
    return res;
};

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/models/ticket.ts
================================================================================
import mongoose, { Schema } from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current'

interface TicketAttrs {
    title: string;
    price: number;
    userId: string;
}

interface TicketDoc extends mongoose.Document {
    title: string;
    price: number;
    userId: string;
    version: number;
    orderId?: string;
}

interface TicketModel extends mongoose.Model<TicketDoc> {
    build(ticketAttrs: TicketAttrs): TicketDoc;
}

const ticketSchema = new Schema(
    {
        title: {
            type: String,
            required: true
        },
        price: {
            type: Number,
            required: true
        },
        userId: {
            type: String,
            required: true
        },
        orderId: {
            type: String
        }
    }, {
        toJSON: {
            transform(_, ret) {
                ret.id = ret._id;
                delete ret._id;
            }
        }
    }
);

ticketSchema.set('versionKey', 'version');
ticketSchema.plugin(updateIfCurrentPlugin);

ticketSchema.statics.build = (attrs: TicketAttrs) => {
    return new Ticket(attrs);
};

const Ticket = mongoose.model<TicketDoc, TicketModel>('Ticket', ticketSchema);

export { Ticket };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/publishers/ticket-updated-publisher.ts
================================================================================
import {
  Subject,
  RabbitMQPublisher,
  TicketUpdatedEvent,
} from "@lt-ticketing/common";

export class TicketUpdatedPublisher extends RabbitMQPublisher<TicketUpdatedEvent> {
  routingKey: Subject.TicketUpdated = Subject.TicketUpdated;
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/publishers/ticket-created-publisher.ts
================================================================================
import {
  Subject,
  RabbitMQPublisher,
  TicketCreatedEvent,
} from "@lt-ticketing/common";

export class TicketCreatedPublisher extends RabbitMQPublisher<TicketCreatedEvent> {
  routingKey: Subject.TicketCreated = Subject.TicketCreated;
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/listeners/order-created-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  RabbitMQListener,
  NotFoundError,
  OrderCreatedEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { TicketUpdatedPublisher } from "../publishers/ticket-updated-publisher";
import { rabbitmqWrapper } from "../../rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends RabbitMQListener<OrderCreatedEvent> {
  routingKey: Subject.OrderCreated = Subject.OrderCreated;
  queueName = QueueGroupName.TicketsService;

  async onMessage(data: OrderCreatedEvent["data"], msg: ConsumeMessage) {
    logger.info("Order created event received", { orderId: data.id });

    const ticket = await Ticket.findById(data.ticket.id);
    if (!ticket) {
      logger.warn("Ticket not found", { ticketId: data.ticket.id });
      throw new Error("Ticket not found.");
    }

    ticket.set({ orderId: data.id });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    await new TicketUpdatedPublisher(rabbitmqWrapper.channel).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    logger.info("Ticket updated event published", { ticketId: ticket.id });

    // Acknowledgment is handled by the base listener class

    logger.info("Order created event acknowledged", { orderId: data.id });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/events/listeners/order-cancelled-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  RabbitMQListener,
  NotFoundError,
  OrderCancelledEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { TicketUpdatedPublisher } from "../publishers/ticket-updated-publisher";
import { rabbitmqWrapper } from "../../rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

export class OrderCancelledListener extends RabbitMQListener<OrderCancelledEvent> {
  routingKey: Subject.OrderCancelled = Subject.OrderCancelled;
  queueName = QueueGroupName.TicketsService;

  async onMessage(data: OrderCancelledEvent["data"], msg: ConsumeMessage) {
    logger.info("Order cancelled event received", { data });

    const ticket = await Ticket.findById(data.ticket.id);
    if (!ticket) {
      logger.warn("Ticket not found", { ticketId: data.ticket.id });
      throw new Error("Ticket not found.");
    }

    // Clear the orderId to un-reserve the ticket
    ticket.set({ orderId: undefined });
    await ticket.save();

    logger.info("Ticket updated - order cancelled", {
      ticketId: ticket.id,
      version: ticket.version,
    });

    await new TicketUpdatedPublisher(rabbitmqWrapper.channel).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    logger.info("Ticket updated event published", { ticketId: ticket.id });

    // Acknowledgment is handled by the base listener class

    logger.info("Order cancelled event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/new.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { requireAuth, validateRequest } from "@lt-ticketing/common";

import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { TicketCreatedPublisher } from "../events/publishers/ticket-created-publisher";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/tickets",
  requireAuth,
  [
    body("title").not().isEmpty().withMessage("Title required."),
    body("price").isFloat({ gt: 0 }).withMessage("Price must be > 0"),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { title, price } = req.body;

    logger.info("Received ticket creation request", {
      title,
      price,
      userId: req.currentUser!.id,
    });

    const ticket = Ticket.build({
      title,
      price,
      userId: req.currentUser!.id,
    });

    await ticket.save();

    logger.info("Ticket created", { ticket });

    await new TicketCreatedPublisher(rabbitmqWrapper.channel).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    logger.info("Ticket creation event published", { ticketId: ticket.id });

    res.status(201).send(ticket);
  }
);

export { router as createTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/index.ts
================================================================================
import express, { Request, Response } from 'express';

import { Ticket } from '../models/ticket';

const router = express.Router();

router.get('/api/tickets', async (req: Request, res: Response) => {
    const tickets = await Ticket.find({});
    res.send(tickets);
});

export { router as indexTicketRouter };

================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/show.ts
================================================================================
import express, { Request, Response } from "express";
import { NotFoundError } from "@lt-ticketing/common";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get("/api/tickets/:id", async (req: Request, res: Response) => {
  logger.info("Received ticket retrieval request", { ticketId: req.params.id });
  const ticket = await Ticket.findById(req.params.id);
  if (!ticket) {
    logger.warn("Ticket not found", { ticketId: req.params.id });
    throw new NotFoundError();
  }

  logger.info("Ticket retrieved", {
    ticketId: ticket.id,
    title: ticket.title,
    price: ticket.price,
    userId: ticket.userId,
    version: ticket.version,
  });

  res.status(200).send(ticket);
});

export { router as showTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/tickets/src/routes/update.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import {
  NotFoundError,
  NotAuthorizedError,
  BadRequestError,
} from "@lt-ticketing/common";
import { requireAuth, validateRequest } from "@lt-ticketing/common";

import { TicketUpdatedPublisher } from "../events/publishers/ticket-updated-publisher";
import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { Ticket } from "../models/ticket";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.put(
  "/api/tickets/:id",
  requireAuth,
  [
    body("title").not().isEmpty().withMessage("Title required."),
    body("price").isFloat({ gt: 0 }).withMessage("Price must be > 0"),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    logger.info("Received ticket update request", {
      ticketId: req.params.id,
      userId: req.currentUser!.id,
    });
    const ticket = await Ticket.findById(req.params.id);

    if (!ticket) {
      logger.warn("Ticket not found", { ticketId: req.params.id });
      throw new NotFoundError();
    }
    if (ticket.orderId) {
      logger.warn("Cannot edit a reserved ticket", { ticketId: ticket.id });
      throw new BadRequestError("Cannot edit a reserved ticket.");
    }
    if (ticket.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to update ticket", {
        ticketId: ticket.id,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    ticket.set({
      title: req.body.title,
      price: req.body.price,
    });
    await ticket.save();

    logger.info("Ticket updated", {
      ticketId: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
    });

    await new TicketUpdatedPublisher(rabbitmqWrapper.channel).publish({
      id: ticket.id,
      title: ticket.title,
      price: ticket.price,
      userId: ticket.userId,
      version: ticket.version,
      orderId: ticket.orderId,
    });

    logger.info("Ticket update event published", { ticketId: ticket.id });

    res.send(ticket);
  }
);

export { router as updateTicketRouter };


================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/listener.ts
================================================================================
import nats, { Message, Stan } from 'node-nats-streaming';
import { randomBytes } from 'crypto';
import { TicketCreatedListener } from './events/ticket-created-listener';

console.clear();

const stan = nats.connect('ticketing', randomBytes(4).toString('hex'), {
  url: 'http://localhost:4222',
});

stan.on('connect', () => {
  console.log('Listener connected to NATS');

  stan.on('close', () => {
    console.log('NATS connection closed!');
    process.exit();
  });

  new TicketCreatedListener(stan).listen();
});

process.on('SIGINT', () => stan.close());
process.on('SIGTERM', () => stan.close());

================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/publisher.ts
================================================================================
import nats from 'node-nats-streaming';
import { TicketCreatedPublisher } from './events/ticket-created-publisher';

console.clear();

const stan = nats.connect('ticketing', 'abc', {
  url: 'http://localhost:4222',
});

stan.on('connect', async () => {
  console.log('Publisher connected to NATS');

  const ticketCreatedPublisher = new TicketCreatedPublisher(stan);

  try{
    await ticketCreatedPublisher.publish({
      id: '123',
      title: 'concert',
      price: 20,
      userId: 'userid'
    });
  } catch(err) {
    console.error(err);
  }
  
});


================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/events/ticket-created-listener.ts
================================================================================
import { Subject, Listener, TicketCreatedEvent } from '@lt-ticketing/common';
import { Message } from 'node-nats-streaming';

export class TicketCreatedListener extends Listener<TicketCreatedEvent> {
    readonly subject: Subject.TicketCreated = Subject.TicketCreated;
    queueGroupName = 'payments-service';
    
    onMessage(data: TicketCreatedEvent['data'], msg: Message) {
      console.log('Event data:', data);
      msg.ack();
    }
  }

================================================================================
File: /Users/luketchang/code/ticketing/nats-test/src/events/ticket-created-publisher.ts
================================================================================
import { Subject, Publisher, TicketCreatedEvent } from "@lt-ticketing/common";

export class TicketCreatedPublisher extends Publisher<TicketCreatedEvent> {
    subject: Subject.TicketCreated = Subject.TicketCreated;
}

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/tracer.ts
================================================================================
import { setupTracing } from "@lt-ticketing/common";

// Initialize OpenTelemetry tracing for this service
setupTracing("payments-service");


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/stripe.ts
================================================================================
import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_KEY!, {
    apiVersion: '2020-08-27'
});

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';
import { createChargeRouter } from './routes/new';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(createChargeRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/rabbitmq-wrapper.ts
================================================================================
import { RabbitMQWrapper, defaultRabbitMQConfig } from "@lt-ticketing/common";

// Re-export the rabbitmqWrapper instance from common
export const rabbitmqWrapper = new RabbitMQWrapper({
  ...defaultRabbitMQConfig,
  // Override URL if needed
  url: process.env.RABBITMQ_URL || "amqp://guest:guest@rabbitmq-srv:5672",
  // Add any service-specific exchanges if needed
  exchanges: [
    ...defaultRabbitMQConfig.exchanges,
    // Add service-specific exchanges here if needed
  ],
});


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "payments" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { OrderCancelledListener } from "./events/listeners/order-cancelled-listener";
import { rabbitmqWrapper } from "./rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.PAYMENTS_MONGO_URI)
    throw new Error("PAYMENTS_MONGO_URI not defined.");
  if (!process.env.RABBITMQ_URL) throw new Error("RABBITMQ_URL not defined.");

  try {
    await rabbitmqWrapper.connect();
    logger.info("Connected to RabbitMQ", {
      url: process.env.RABBITMQ_URL,
    });

    process.on("SIGINT", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    process.on("SIGTERM", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    new OrderCreatedListener(rabbitmqWrapper.channel).listen();
    new OrderCancelledListener(rabbitmqWrapper.channel).listen();

    logger.info("Listeners started");

    await mongoose.connect(process.env.PAYMENTS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");

    app.listen(3000, () => {
      logger.info("Payments service listening on port 3000!");
    });
  } catch (err) {
    logger.error("Error during startup", { error: err });
    process.exit(1);
  }
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/__mocks__/stripe.ts
================================================================================
export const stripe = {
    charges: {
        create: jest.fn().mockResolvedValue({ id: 'MOCK_ID' })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/__mocks__/rabbitmq-wrapper.ts
================================================================================
// Mock for the RabbitMQ wrapper to be used in tests
export const rabbitmqWrapper = {
  channel: {
    publish: jest.fn().mockImplementation(() => {}),
    assertExchange: jest.fn().mockResolvedValue({}),
    assertQueue: jest.fn().mockResolvedValue({}),
    bindQueue: jest.fn().mockResolvedValue({}),
    consume: jest.fn().mockResolvedValue({}),
    prefetch: jest.fn().mockResolvedValue({}),
    ack: jest.fn().mockImplementation(() => {}),
    nack: jest.fn().mockImplementation(() => {}),
  },
  connect: jest.fn().mockResolvedValue({}),
  close: jest.fn().mockResolvedValue({}),
};


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = (id: string) => {
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from "mongodb-memory-server";
import mongoose from "mongoose";

jest.mock("../rabbitmq-wrapper");

let mongo: any;
beforeAll(async () => {
  process.env.JWT_KEY = "JWT_TEST_KEY";

  mongo = new MongoMemoryServer();
  const mongoUri = await mongo.getUri();

  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

beforeEach(async () => {
  jest.clearAllMocks();
  const collections = await mongoose.connection.db.collections();
  for (let collection of collections) {
    await collection.deleteMany({});
  }
});

afterAll(async () => {
  await mongo.stop();
  await mongoose.connection.close();
});


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/test/createTicket.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const createTicket = async (title: string, price: number, cookie: string[]) => {
    const res = await request(app)
        .post('/api/tickets')
        .set('Cookie', cookie)
        .send({
            title,
            price
        })
        .expect(201);
    
    return res;
};

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/models/payment.ts
================================================================================
import mongoose from 'mongoose';

interface PaymentAttrs {
    orderId: string;
    stripeId: string;
}

interface PaymentDoc extends mongoose.Document {
    orderId: string;
    stripeId: string;
}

interface PaymentModel extends mongoose.Model<PaymentDoc> {
    build(attrs: PaymentAttrs): PaymentDoc;
}

const paymentSchema = new mongoose.Schema({
    orderId: {
        type: String,
        required: true
    },
    stripeId: {
        type: String,
        required: true
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

paymentSchema.statics.build = (attrs: PaymentAttrs) => {
    return new Payment(attrs);
}

const Payment = mongoose.model<PaymentDoc, PaymentModel>('Payment', paymentSchema);

export { Payment };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/models/order.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { OrderStatus } from '@lt-ticketing/common';

interface OrderAttrs {
    id: string;
    price: number;
    userId: string;
    status: OrderStatus;
    version: number;
}

interface OrderDoc extends mongoose.Document {
    price: number;
    userId: string;
    status: OrderStatus;
    version: number;
}

interface OrderModel extends mongoose.Model<OrderDoc> {
    build(attrs: OrderAttrs): OrderDoc;
}

const orderSchema = new mongoose.Schema ({
    userId: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true
    },
    status: {
        type: String,
        required: true,
        enum: Object.values(OrderStatus)
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

orderSchema.set('versionKey', 'version');
orderSchema.plugin(updateIfCurrentPlugin);

orderSchema.statics.build = (attrs: OrderAttrs) => {
    return new Order({
        _id: attrs.id,
        price: attrs.price,
        userId: attrs.userId,
        status: attrs.status,
        version: attrs.version
    });
}

const Order = mongoose.model<OrderDoc, OrderModel>('Order', orderSchema);

export { Order };

================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/publishers/payment-created-publisher.ts
================================================================================
import {
  Subject,
  RabbitMQPublisher,
  PaymentCreatedEvent,
} from "@lt-ticketing/common";

export class PaymentCreatedPublisher extends RabbitMQPublisher<PaymentCreatedEvent> {
  routingKey: Subject.PaymentCreated = Subject.PaymentCreated;
}


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/listeners/order-created-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  RabbitMQListener,
  OrderCreatedEvent,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends RabbitMQListener<OrderCreatedEvent> {
  routingKey: Subject.OrderCreated = Subject.OrderCreated;
  queueName = QueueGroupName.PaymentsService;

  async onMessage(
    data: OrderCreatedEvent["data"],
    msg: ConsumeMessage
  ): Promise<void> {
    logger.info("Order created event received", { orderId: data.id });

    const order = Order.build({
      id: data.id,
      price: data.ticket.price,
      userId: data.userId,
      status: data.status,
      version: data.version,
    });
    await order.save();

    logger.info("Order created", {
      orderId: order.id,
      userId: order.userId,
      price: order.price,
      status: order.status,
      version: order.version,
    });

    logger.info("Order created event acknowledged", { orderId: order.id });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/events/listeners/order-cancelled-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  RabbitMQListener,
  OrderCancelledEvent,
  OrderStatus,
  QueueGroupName,
  Subject,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class OrderCancelledListener extends RabbitMQListener<OrderCancelledEvent> {
  routingKey: Subject.OrderCancelled = Subject.OrderCancelled;
  queueName = QueueGroupName.PaymentsService;

  async onMessage(
    data: OrderCancelledEvent["data"],
    msg: ConsumeMessage
  ): Promise<void> {
    logger.info("Order cancelled event received", { data });

    const order = await Order.findOne({
      _id: data.id,
      version: data.version - 1,
    });

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found.");
    }

    order.set({ status: OrderStatus.Cancelled });
    await order.save();

    logger.info("Order cancelled", { data });

    logger.info("Order cancelled event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/payments/src/routes/new.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import {
  requireAuth,
  validateRequest,
  BadRequestError,
  NotFoundError,
  NotAuthorizedError,
  OrderStatus,
} from "@lt-ticketing/common";
import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { PaymentCreatedPublisher } from "../events/publishers/payment-created-publisher";
import { Order } from "../models/order";
import { Payment } from "../models/payment";
import { stripe } from "../stripe";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/payments",
  requireAuth,
  [body("token").not().isEmpty(), body("orderId").not().isEmpty()],
  validateRequest,
  async (req: Request, res: Response) => {
    const { token, orderId } = req.body;

    logger.info("Received payment creation request", {
      orderId,
      userId: req.currentUser?.id,
    });
    const order = await Order.findById(orderId);

    if (!order) {
      logger.warn("Order not found", { orderId: orderId });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized", {
        orderId: orderId,
        userId: req.currentUser?.id,
      });
      throw new NotAuthorizedError();
    }
    if (order.status === OrderStatus.Cancelled) {
      logger.warn("Cannot pay for cancelled order", { orderId: orderId });
      throw new BadRequestError("Cannot pay for cancelled order.");
    }

    const charge = await stripe.charges.create({
      currency: "usd",
      amount: order.price * 100,
      source: token,
    });

    const payment = Payment.build({
      orderId,
      stripeId: charge.id,
    });
    await payment.save();

    logger.info("Payment created", {
      paymentId: payment.id,
      orderId: payment.orderId,
      stripeId: payment.stripeId,
    });

    await new PaymentCreatedPublisher(rabbitmqWrapper.channel).publish({
      id: payment.id,
      orderId: payment.orderId,
      stripeId: payment.stripeId,
    });

    logger.info("Payment created event published", { paymentId: payment.id });

    res.status(201).send(payment);
  }
);

export { router as createChargeRouter };


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/debug-pod.yaml
================================================================================
apiVersion: v1
kind: Pod
metadata:
  name: debug-pod
spec:
  serviceAccountName: default
  containers:
    - name: debug
      image: curlimages/curl
      command: ["sh", "-c", "sleep infinity"]
  restartPolicy: Never


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/nats-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nats-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nats
  template:
    metadata:
      labels:
        app: nats
    spec:
      containers:
        - name: nats
          image: nats-streaming:0.17.0
          args: 
            [
              '-p',
              '4222',
              '-m',
              '8222',
              '-hbi',
              '5s',
              '-hbt',
              '5s',
              '-hbf',
              '2',
              '-SD',
              '-cid',
              'ticketing'
            ]
---
apiVersion: v1
kind: Service
metadata:
  name: nats-srv
spec:
  type: ClusterIP
  selector:
    app: nats
  ports:
    - name: client
      protocol: TCP
      port: 4222
      targetPort: 4222
    - name: monitoring
      protocol: TCP
      port: 8222
      targetPort: 8222


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/orders-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orders-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orders-mongo
  template:
    metadata:
      labels:
        app: orders-mongo
    spec:
      containers:
        - name: orders-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: orders-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: orders-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/tickets-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tickets-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tickets-mongo
  template:
    metadata:
      labels:
        app: tickets-mongo
    spec:
      containers:
        - name: tickets-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: tickets-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: tickets-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana-alloy
  namespace: default
  labels:
    app: grafana-alloy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana-alloy
  template:
    metadata:
      labels:
        app: grafana-alloy
    spec:
      containers:
        - name: grafana-alloy
          image: grafana/alloy:latest
          args:
            - run
            - /etc/alloy/alloy.hcl
          env:
            - name: LOKI_USERNAME
              valueFrom:
                secretKeyRef:
                  name: loki-credentials
                  key: username
            - name: LOKI_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: loki-credentials
                  key: password
            - name: LOG_LEVEL
              value: "debug"
          volumeMounts:
            - name: config
              mountPath: /etc/alloy
            - name: containers
              mountPath: /var/log/containers
              readOnly: true
            - name: pods
              mountPath: /var/log/pods
              readOnly: true
            - name: docker-containers
              mountPath: /var/lib/docker/containers
              readOnly: true
      volumes:
        - name: config
          configMap:
            name: alloy-config
        - name: containers
          hostPath:
            path: /var/log/containers
            type: Directory
        - name: pods
          hostPath:
            path: /var/log/pods
            type: Directory
        - name: docker-containers
          hostPath:
            path: /var/lib/docker/containers
            type: Directory


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/datadog-agent.yaml
================================================================================
apiVersion: datadoghq.com/v2alpha1
kind: DatadogAgent
metadata:
  name: datadog
spec:
  features:
    logCollection:
      enabled: true
      containerCollectAll: true
    apm:
      enabled: true
      unixDomainSocketConfig:
        path: /var/run/datadog/apm.socket
    admissionController:
      enabled: true
      mutateUnlabelled: false
  global:
    clusterName: docker-desktop
    credentials:
      apiSecret:
        secretName: datadog-secret
        keyName: api-key
      appSecret:
        secretName: datadog-secret
        keyName: app-key
  override:
    nodeAgent:
      env:
        - name: DD_KUBELET_TLS_VERIFY
          value: "false"


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/client-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: client
  template:
    metadata:
      labels:
        app: client
        admission.datadoghq.com/enabled: "true"
      annotations:
        admission.datadoghq.com/js-lib.version: "v5.45.0"
    spec:
      containers:
        - name: client
          image: luketchang/client
          env:
            - name: SERVICE_NAME
              value: "client"
            - name: NODE_OPTIONS
              value: "--openssl-legacy-provider"

---
apiVersion: v1
kind: Service
metadata:
  name: client-srv
spec:
  type: ClusterIP
  selector:
    app: client
  ports:
    - name: client
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: loki-credentials
  namespace: default
type: Opaque
data:
  username: MTEzNTg5Mw== # Base64-encoded "1135893"
  password: Z2xjX2V5SnZJam9pTVRNMU5UY3lNeUlzSW00aU9pSnpkR0ZqYXkweE1UYzRNRGswTFdoc0xYSmxZV1F0WVd4c0lpd2lheUk2SW5Cbk1EUkVhWE5UV0hKc1RqWTJVREpqTWxFME1XbzJNU0lzSW0waU9uc2ljaUk2SW5CeWIyUXRkWE10ZDJWemRDMHdJbjE5 # Base64-encoded secret


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/services-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
  namespace: default
type: Opaque
data:
  JWT_KEY: c29tZS1zZWNyZXQta2V5 # Base64-encoded "some-secret-key"

---
apiVersion: v1
kind: Secret
metadata:
  name: stripe-secret
  namespace: default
type: Opaque
data:
  STRIPE_KEY: c2tfdGVzdF81MVF1MXEwR0xPYkNabzh6bVhhVEt1ajZLSEtVdVQ1WVJLU3NOcHJNa3RYbVBHeU9UNllYb2ZSS0d5TkNNaTdCN0wxZjFIYnR4WHppS0ZlSDBZSFU1S3JRTTAwYjIzV09iYXQ= # Base64-encoded secret key


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-config.yaml
================================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
  namespace: default
data:
  alloy.hcl: |
    discovery.kubernetes "pod" {
      role = "pod"
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pod.targets

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex = "auth|payments|orders|tickets|expiration"
        action = "replace"
        target_label = "app_group"
        replacement = "application"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action = "replace"
        target_label = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action = "replace"
        target_label = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        action = "replace"
        target_label = "app"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "job"
        separator = "/"
        replacement = "$1"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        action = "replace"
        target_label = "__path__"
        separator = "/"
        replacement = "/var/log/pods/*$1/*.log"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_id"]
        action = "replace"
        target_label = "container_runtime"
        regex = "^(\\S+):\\/\\/.+$"
        replacement = "$1"
      }
    }

    loki.source.kubernetes "pod_logs" {
      targets    = discovery.relabel.pod_logs.output
      forward_to = [loki.process.pod_logs.receiver]
    }

    loki.process "pod_logs" {
      stage.static_labels {
          values = {
            cluster = "docker-desktop",
          }
      }
      forward_to = [loki.write.default.receiver]
    }

    loki.write "default" {
      endpoint {
        url = "https://logs-prod-021.grafana.net/loki/api/v1/push"
        basic_auth {
          username = sys.env("LOKI_USERNAME")
          password = sys.env("LOKI_PASSWORD")
        }
      }
    }


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/rabbitmq-secret.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: rabbitmq-secret
type: Opaque
data:
  RABBITMQ_DEFAULT_USER: Z3Vlc3Q= # guest (base64 encoded)
  RABBITMQ_DEFAULT_PASS: Z3Vlc3Q= # guest (base64 encoded)


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/expiration-redis-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
    name: expiration-redis-depl
spec:
    replicas: 1
    selector:
        matchLabels:
            app: expiration-redis
    template:
        metadata:
            labels:
                app: expiration-redis
        spec:
            containers:
                - name: expiration-redis
                  image: redis
---
apiVersion: v1
kind: Service
metadata:
    name: expiration-redis-srv
spec:
    type: ClusterIP
    selector:
        app: expiration-redis
    ports:
        - name: db
          protocol: TCP
          port: 6379
          targetPort: 6379

================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/ingress-srv.yaml
================================================================================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-service
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/use-regex: 'true'
spec:
  rules:
    - host: ticketing.dev
      http:
        paths:
          - path: /api/payments/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: payments-srv
                port:
                  number: 3000
          - path: /api/users/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: auth-srv
                port:
                  number: 3000
          - path: /api/tickets/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: tickets-srv
                port:
                  number: 3000
          - path: /api/orders/?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: orders-srv
                port:
                  number: 3000
          - path: /?(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: client-srv
                port:
                  number: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/auth-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: auth
  template:
    metadata:
      labels:
        app: auth
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: auth
          image: luketchang/auth
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: SERVICE_NAME
              value: "auth"
            - name: AUTH_MONGO_URI
              value: "mongodb://auth-mongo-srv:27017/auth"
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-collector:4318/v1/traces"
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: auth-srv
spec:
  type: ClusterIP
  selector:
    app: auth
  ports:
    - name: auth
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/auth-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: auth-mongo
  template:
    metadata:
      labels:
        app: auth-mongo
    spec:
      containers:
        - name: auth-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: auth-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: auth-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/otel-collector-depl.yaml
================================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-collector-conf
data:
  otel-collector-config.yaml: |
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
          http:
            endpoint: 0.0.0.0:4318

    processors:
      batch:
        timeout: 1s
        send_batch_size: 1024

    exporters:
      logging:
        verbosity: detailed

      # Configure this section with your actual tracing backend (e.g., Jaeger, Zipkin, etc.)
      # This is just a placeholder - replace with your actual exporter configuration
      otlp:
        endpoint: "your-tracing-backend:4317"
        tls:
          insecure: true

    service:
      pipelines:
        traces:
          receivers: [otlp]
          processors: [batch]
          exporters: [logging, otlp]
        metrics:
          receivers: [otlp]
          processors: [batch]
          exporters: [logging, otlp]
        logs:
          receivers: [otlp]
          processors: [batch]
          exporters: [logging, otlp]

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-collector
spec:
  replicas: 1
  selector:
    matchLabels:
      app: otel-collector
  template:
    metadata:
      labels:
        app: otel-collector
    spec:
      containers:
        - name: otel-collector
          image: otel/opentelemetry-collector-contrib:0.96.0
          resources:
            limits:
              cpu: 200m
              memory: 400Mi
            requests:
              cpu: 100m
              memory: 200Mi
          ports:
            - containerPort: 4317 # OTLP gRPC
              name: otlp-grpc
            - containerPort: 4318 # OTLP HTTP
              name: otlp-http
            - containerPort: 8888 # Prometheus metrics
              name: metrics
          volumeMounts:
            - name: otel-collector-config-vol
              mountPath: /etc/otel-collector-contrib/
      volumes:
        - name: otel-collector-config-vol
          configMap:
            name: otel-collector-conf
            items:
              - key: otel-collector-config.yaml
                path: config.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: otel-collector
spec:
  type: ClusterIP
  selector:
    app: otel-collector
  ports:
    - name: otlp-grpc
      port: 4317
      targetPort: 4317
      protocol: TCP
    - name: otlp-http
      port: 4318
      targetPort: 4318
      protocol: TCP
    - name: metrics
      port: 8888
      targetPort: 8888
      protocol: TCP 

================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/tickets-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tickets-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tickets
  template:
    metadata:
      labels:
        app: tickets
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: tickets
          image: luketchang/tickets
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: SERVICE_NAME
              value: "tickets"
            - name: TICKETS_MONGO_URI
              value: "mongodb://tickets-mongo-srv:27017/tickets"
            - name: RABBITMQ_URL
              value: "amqp://guest:guest@rabbitmq-srv:5672"
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-collector:4318/v1/traces"
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: tickets-srv
spec:
  type: ClusterIP
  selector:
    app: tickets
  ports:
    - name: tickets
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/rabbitmq-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rabbitmq-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rabbitmq
  template:
    metadata:
      labels:
        app: rabbitmq
    spec:
      containers:
        - name: rabbitmq
          image: rabbitmq:3.12-management
          ports:
            - containerPort: 5672
              name: amqp
            - containerPort: 15672
              name: management
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: RABBITMQ_DEFAULT_USER
              valueFrom:
                secretKeyRef:
                  name: rabbitmq-secret
                  key: RABBITMQ_DEFAULT_USER
            - name: RABBITMQ_DEFAULT_PASS
              valueFrom:
                secretKeyRef:
                  name: rabbitmq-secret
                  key: RABBITMQ_DEFAULT_PASS
---
apiVersion: v1
kind: Service
metadata:
  name: rabbitmq-srv
spec:
  type: ClusterIP
  selector:
    app: rabbitmq
  ports:
    - name: amqp
      protocol: TCP
      port: 5672
      targetPort: 5672
    - name: management
      protocol: TCP
      port: 15672
      targetPort: 15672


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/payments-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payments-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payments
  template:
    metadata:
      labels:
        app: payments
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: payments
          image: luketchang/payments
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: SERVICE_NAME
              value: "payments"
            - name: PAYMENTS_MONGO_URI
              value: "mongodb://payments-mongo-srv:27017/payments"
            - name: RABBITMQ_URL
              value: "amqp://guest:guest@rabbitmq-srv:5672"
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-collector:4318/v1/traces"
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY
            - name: STRIPE_KEY
              valueFrom:
                secretKeyRef:
                  name: stripe-secret
                  key: STRIPE_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: payments-srv
spec:
  type: ClusterIP
  selector:
    app: payments
  ports:
    - name: payments
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/datadog-agent-secrets.yaml
================================================================================
apiVersion: v1
kind: Secret
metadata:
  name: datadog-secret
type: Opaque
data:
  api-key: YTVjOTU1ZDMxY2Q3NTY1YTNkMGViZGI3Y2QzYTc4NzA=
  app-key: YjcyZmY0NDI5MzhkMzBkNjFmYmJlMmEzNTk4MGZkMTcwZTg4ODUxNQ==


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/orders-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orders-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orders
  template:
    metadata:
      labels:
        app: orders
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: orders
          image: luketchang/orders
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: SERVICE_NAME
              value: "orders"
            - name: ORDERS_MONGO_URI
              value: "mongodb://orders-mongo-srv:27017/orders"
            - name: RABBITMQ_URL
              value: "amqp://guest:guest@rabbitmq-srv:5672"
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-collector:4318/v1/traces"
            - name: JWT_KEY
              valueFrom:
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY

---
apiVersion: v1
kind: Service
metadata:
  name: orders-srv
spec:
  type: ClusterIP
  selector:
    app: orders
  ports:
    - name: orders
      protocol: TCP
      port: 3000
      targetPort: 3000


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/expiration-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: expiration-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: expiration
  template:
    metadata:
      labels:
        app: expiration
        admission.datadoghq.com/enabled: "true"
    spec:
      containers:
        - name: expiration
          image: luketchang/expiration
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          env:
            - name: SERVICE_NAME
              value: "expiration"
            - name: RABBITMQ_URL
              value: "amqp://guest:guest@rabbitmq-srv:5672"
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: "http://otel-collector:4318/v1/traces"
            - name: REDIS_HOST
              value: expiration-redis-srv


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/alloy-rbac.yaml
================================================================================
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: alloy-logs
rules:
  - apiGroups: [""]
    resources: ["pods", "pods/log"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: alloy-logs-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: alloy-logs
subjects:
  - kind: ServiceAccount
    name: default
    namespace: default


================================================================================
File: /Users/luketchang/code/ticketing/infra/k8s/payments-mongo-depl.yaml
================================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payments-mongo-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payments-mongo
  template:
    metadata:
      labels:
        app: payments-mongo
    spec:
      containers:
        - name: payments-mongo
          image: mongo
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: payments-mongo-srv
spec:
  type: ClusterIP
  selector:
    app: payments-mongo
  ports:
    - name: db
      protocol: TCP
      port: 27017
      targetPort: 27017


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/tracer.ts
================================================================================
import tracer from "dd-trace";
tracer.init();
export default tracer;


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError } from '@lt-ticketing/common';

import { currentUserRouter } from './routes/currentuser';
import { signinRouter } from './routes/signin';
import { signoutRouter } from './routes/signout';
import { signupRouter } from './routes/signup';

const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);

app.use(currentUserRouter);
app.use(signinRouter);
app.use(signoutRouter);
app.use(signupRouter);
app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) {
    throw new Error("JWT_KEY not defined.");
  }
  if (!process.env.AUTH_MONGO_URI) {
    throw new Error("JWT_KEY not defined.");
  }

  try {
    await mongoose.connect(process.env.AUTH_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");
  } catch (err) {
    logger.error(err);
  }

  app.listen(3000, () => {
    logger.info("Listening on port 3000!");
  });
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/__mocks__/tracing.ts
================================================================================
export const setupTracing = jest.fn();
export const tracer = {
  startSpan: jest.fn().mockReturnValue({
    setStatus: jest.fn(),
    end: jest.fn(),
    recordException: jest.fn(),
  }),
};
export const createMessageProducerSpan = jest.fn().mockReturnValue({
  setStatus: jest.fn(),
  end: jest.fn(),
  recordException: jest.fn(),
});
export const createMessageConsumerSpan = jest.fn().mockReturnValue({
  setStatus: jest.fn(),
  end: jest.fn(),
  recordException: jest.fn(),
});
export const traceMessageProcessing = jest
  .fn()
  .mockImplementation((span, fn) => fn());


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/test/getAuthCookie.ts
================================================================================
import request from 'supertest';

import { app } from '../app';

export const getAuthCookie = async () => {
    const email = 'test@test.com';
    const password = 'password';

    const res = await request(app)
        .post('/api/users/signup')
        .send({
            email,
            password
        })
        .expect(201);

    return res.get('Set-Cookie');
};

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from "mongodb-memory-server";
import mongoose from "mongoose";
import { app } from "../app";
import request from "supertest";

// Mock the common library's tracing module
jest.mock("@lt-ticketing/common", () => {
  const originalModule = jest.requireActual("@lt-ticketing/common");
  return {
    ...originalModule,
    setupTracing: jest.fn(),
    logger: {
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
    },
  };
});

let mongo: any;

beforeAll(async () => {
  process.env.JWT_KEY = "JWT_TEST_KEY";

  mongo = new MongoMemoryServer();
  const mongoUri = await mongo.getUri();

  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

beforeEach(async () => {
  const collections = await mongoose.connection.db.collections();

  for (let collection of collections) {
    await collection.deleteMany({});
  }
});

afterAll(async () => {
  await mongo.stop();
  await mongoose.connection.close();
});


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/utils/password.ts
================================================================================
import { scrypt, randomBytes } from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(scrypt);

export class Password {
    static async hashPassword(password: string) {
        const salt = randomBytes(8).toString('hex');
        const buf = (await scryptAsync(password, salt, 64)) as Buffer;

        return `${buf.toString('hex')}.${salt}`;
    }

    static async comparePasswords(storedPassword: string, suppliedPassword: string) {
        const [hashedPassword, salt] = storedPassword.split('.');
        const buf = (await scryptAsync(suppliedPassword, salt, 64)) as Buffer;
        
        return buf.toString('hex') === hashedPassword;
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/models/user.ts
================================================================================
import mongoose, { Schema } from 'mongoose';
import { Password } from '../utils/password';

interface UserAttrs {
    email: string;
    password: string;
}

interface UserDoc extends mongoose.Document {
   email: string;
   password: string; 
}

interface UserModel extends mongoose.Model<UserDoc> {
    build(attrs: UserAttrs): UserDoc;
}

const userSchema = new Schema(
    {
        email: {
            type: String,
            required: true
        },
        password: {
            type: String,
            required: true
        }
    }, {
        toJSON: {
            transform(_, ret) {
                ret.id = ret._id;
                delete ret._id;
                delete ret.password;
                delete ret.__v;
            }
        }
    }
);

userSchema.pre('save', async function() {
    if(this.isModified('password')) {
        const hashed = await Password.hashPassword(this.get('password'));
        this.set('password', hashed);
    }
});

userSchema.statics.build = (attrs: UserAttrs) => {
    return new User(attrs);
}

const User = mongoose.model<UserDoc, UserModel>('User', userSchema);

export { User };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signout.ts
================================================================================
import express from "express";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post("/api/users/signout", (req, res) => {
  const sessionId = req.session?.id;
  const sessionEmail = req.session?.email;

  logger.info("Received sign out request", { sessionEmail, sessionId });
  req.session = null;

  logger.info("User signed out", { sessionEmail, sessionId });
  res.send("Signed out.");
});

export { router as signoutRouter };


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/currentuser.ts
================================================================================
import express from "express";
import { currentUser } from "@lt-ticketing/common";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get("/api/users/currentuser", currentUser, (req, res) => {
  logger.info("Handling request for current user", {
    currentUser: req.currentUser,
  });
  res.send({ currentUser: req.currentUser || null });
});

export { router as currentUserRouter };


================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signin.ts
================================================================================
import express, { Request, Response } from 'express';
import { body } from 'express-validator';
import jwt from 'jsonwebtoken';
import { validateRequest, BadRequestError } from '@lt-ticketing/common';
import { User } from '../models/user'; 
import { Password } from '../utils/password';
import { logger } from '@lt-ticketing/common';

const router = express.Router();

router.post(
    '/api/users/signin', 
    [
        body('email')
            .isEmail()
            .withMessage('Please enter valid email.'),
        body('password')
            .trim()
            .notEmpty()
            .withMessage('Must supply a password')
    ],
    validateRequest,
    async (req: Request, res: Response) => {
        const { email, password } = req.body;
        logger.info('Received sign in request', { email });
        

        const existingUser = await User.findOne({ email });
        if(!existingUser) {
            logger.warn('User not found', { email });
            throw new BadRequestError('Invalid email.');
        }

        logger.info('User found', { email, userId: existingUser.id });
        const passwordsMatch = await Password.comparePasswords(existingUser.password, password);
        if(!passwordsMatch) {
            logger.warn('Invalid password', { email, userId: existingUser.id });
            throw new BadRequestError('Invalid password.')
        }

        logger.info('Password matches', { email, userId: existingUser.id });
        const userJwt = jwt.sign(
            {
                id: existingUser.id,
                email: existingUser.email
            }, 
            process.env.JWT_KEY!
        );

        req.session = {
            email,
            jwt: userJwt
        };

        logger.info('User signed in', { email, userId: existingUser.id });
        res.status(200).send(existingUser);
    }
);

export { router as signinRouter };

================================================================================
File: /Users/luketchang/code/ticketing/auth/src/routes/signup.ts
================================================================================
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { User } from "../models/user";
import jwt from "jsonwebtoken";
import { validateRequest, BadRequestError } from "@lt-ticketing/common";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.post(
  "/api/users/signup",
  [
    body("email").isEmail().withMessage("Please enter valid email."),
    body("password")
      .trim()
      .isLength({ min: 4, max: 20 })
      .withMessage("Password must be between 4 and 20 characters."),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { email, password } = req.body;

    logger.info("Received sign up request", { email });

    const userExists = await User.findOne({ email });
    if (userExists) {
      logger.warn("Email already in use", { email });
      throw new BadRequestError("Email already in use.");
    }

    const newUser = User.build({ email, password });
    await newUser.save();

    logger.info("User created", { email, userId: newUser.id });
    const userJwt = jwt.sign(
      {
        id: newUser.id,
        email: newUser.email,
      },
      process.env.JWT_KEY!
    );

    req.session = {
      jwt: userJwt,
    };

    logger.info("User signed up", { email, userId: newUser.id });
    res.status(201).send(newUser);
  }
);

export { router as signupRouter };


================================================================================
File: /Users/luketchang/code/ticketing/common/build/tracing.d.ts
================================================================================
import { Span } from "@opentelemetry/api";
export declare const tracer: import("@opentelemetry/api").Tracer;
export declare const setupTracing: (serviceName: string) => void;
export declare const createMessageProducerSpan: (exchange: string, routingKey: string, messageId: string) => Span;
export declare const createMessageConsumerSpan: (exchange: string, routingKey: string, queue: string, messageId: string) => Span;
export declare const traceMessageProcessing: <T>(span: Span, processFn: () => Promise<T>) => Promise<T>;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/mcp-server.d.ts
================================================================================
export {};


================================================================================
File: /Users/luketchang/code/ticketing/common/build/logger.d.ts
================================================================================
import winston from "winston";
declare const logger: winston.Logger;
export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/common/build/index.d.ts
================================================================================
export * from "./errors/bad-request-error";
export * from "./errors/custom-error";
export * from "./errors/database-connection-error";
export * from "./errors/not-authorized-error";
export * from "./errors/not-found-error";
export * from "./errors/request-validation-error";
export * from "./middlewares/current-user";
export * from "./middlewares/error-handler";
export * from "./middlewares/require-auth";
export * from "./middlewares/validate-request";
export * from "./events/subject";
export * from "./events/base-event";
export * from "./events/base-publisher";
export * from "./events/base-listener";
export * from "./events/ticket-created-event";
export * from "./events/ticket-updated-event";
export * from "./events/order-created-event";
export * from "./events/order-cancelled-event";
export * from "./events/types/order-status";
export * from "./events/types/queue-group-names";
export * from "./events/expiration-complete-event";
export * from "./events/payment-created-event";
export * from "./messaging/rabbitmq-wrapper";
export { Publisher as RabbitMQPublisher } from "./messaging/base-publisher";
export { Listener as RabbitMQListener } from "./messaging/base-listener";
export * from "./tracing";
export { logger } from "./logger";
export * from "./mcp-server";


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/current-user.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
interface UserPayload {
    id: string;
    email: string;
}
declare global {
    namespace Express {
        interface Request {
            currentUser?: UserPayload;
        }
    }
}
export declare const currentUser: (req: Request, res: Response, next: NextFunction) => void;
export {};


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/require-auth.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const requireAuth: (req: Request, res: Response, next: NextFunction) => void;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/validate-request.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const validateRequest: (req: Request, res: Response, next: NextFunction) => void;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/middlewares/error-handler.d.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
export declare const errorHandler: (err: Error, req: Request, res: Response, next: NextFunction) => Response<any> | undefined;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/not-found-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class NotFoundError extends CustomError {
    constructor();
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/request-validation-error.d.ts
================================================================================
import { ValidationError } from 'express-validator';
import { CustomError } from './custom-error';
export declare class RequestValidationError extends CustomError {
    errors: ValidationError[];
    constructor(errors: ValidationError[]);
    statusCode: number;
    serializeErrors(): {
        message: any;
        field: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/bad-request-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class BadRequestError extends CustomError {
    message: string;
    constructor(message: string);
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/not-authorized-error.d.ts
================================================================================
import { CustomError } from './custom-error';
export declare class NotAuthorizedError extends CustomError {
    constructor();
    statusCode: number;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/database-connection-error.d.ts
================================================================================
import { CustomError } from "./custom-error";
export declare class DatabaseConnectionError extends CustomError {
    constructor();
    statusCode: number;
    reason: string;
    serializeErrors(): {
        message: string;
    }[];
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/errors/custom-error.d.ts
================================================================================
export declare abstract class CustomError extends Error {
    abstract statusCode: number;
    abstract serializeErrors(): {
        message: string;
        field?: string;
    }[];
    constructor(message: string);
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/ticket-updated-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface TicketUpdatedEvent extends Event {
    subject: Subject.TicketUpdated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
        orderId?: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/order-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';
export interface OrderCreatedEvent extends Event {
    subject: Subject.OrderCreated;
    data: {
        id: string;
        status: OrderStatus;
        userId: string;
        expiresAt: string;
        version: number;
        ticket: {
            id: string;
            price: number;
        };
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/order-cancelled-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface OrderCancelledEvent extends Event {
    subject: Subject.OrderCancelled;
    data: {
        id: string;
        version: number;
        ticket: {
            id: string;
        };
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/payment-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface PaymentCreatedEvent extends Event {
    subject: Subject.PaymentCreated;
    data: {
        id: string;
        orderId: string;
        stripeId: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/ticket-created-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface TicketCreatedEvent extends Event {
    subject: Subject.TicketCreated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/expiration-complete-event.d.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
export interface ExpirationCompleteEvent extends Event {
    subject: Subject.ExpirationComplete;
    data: {
        orderId: string;
    };
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-publisher.d.ts
================================================================================
import { Stan } from "node-nats-streaming";
import { Event } from "./base-event";
export declare abstract class Publisher<T extends Event> {
    abstract subject: T["subject"];
    protected client: Stan;
    constructor(client: Stan);
    publish(data: T["data"]): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-listener.d.ts
================================================================================
import { Message, Stan } from "node-nats-streaming";
import { Event } from "./base-event";
export declare abstract class Listener<T extends Event> {
    abstract subject: T["subject"];
    abstract queueGroupName: string;
    abstract onMessage(data: T["data"], msg: Message): void;
    protected client: Stan;
    protected ackWait: number;
    constructor(client: Stan);
    subscriptionOptions(): import("node-nats-streaming").SubscriptionOptions;
    listen(): void;
    parseMessage(msg: Message): any;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/subject.d.ts
================================================================================
export declare enum Subject {
    TicketCreated = "ticket:created",
    TicketUpdated = "ticket:updated",
    OrderCreated = "order:created",
    OrderCancelled = "order:cancelled",
    ExpirationComplete = "expiration:complete",
    PaymentCreated = "payment:created"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/base-event.d.ts
================================================================================
import { Subject } from './subject';
export interface Event {
    subject: Subject;
    data: any;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/types/order-status.d.ts
================================================================================
export declare enum OrderStatus {
    Created = "created",
    Cancelled = "cancelled",
    AwaitingPayment = "awaiting:payment",
    Complete = "complete"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/events/types/queue-group-names.d.ts
================================================================================
export declare enum QueueGroupName {
    OrdersService = "orders-service",
    TicketsService = "tickets-service",
    PaymentsService = "payments-service",
    ExpirationService = "expiration-service"
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/rabbitmq-wrapper.d.ts
================================================================================
import * as amqplib from "amqplib";
export interface RabbitMQConfig {
    url: string;
    exchanges: ExchangeConfig[];
}
export interface ExchangeConfig {
    name: string;
    type: string;
    options?: amqplib.Options.AssertExchange;
}
export declare class RabbitMQWrapper {
    private _connection?;
    private _channel?;
    private _config;
    private _initialized;
    constructor(config: RabbitMQConfig);
    get channel(): amqplib.Channel;
    get connection(): amqplib.Connection;
    get isInitialized(): boolean;
    connect(): Promise<void>;
    close(): Promise<void>;
}
export declare const defaultRabbitMQConfig: RabbitMQConfig;
export declare const rabbitmqWrapper: RabbitMQWrapper;


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/base-publisher.d.ts
================================================================================
import { Channel } from "amqplib";
import { Event } from "../events/base-event";
export declare abstract class Publisher<T extends Event> {
    abstract routingKey: T["subject"];
    protected channel: Channel;
    protected exchange: string;
    constructor(channel: Channel, exchange?: string);
    publish(data: T["data"]): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/base-listener.d.ts
================================================================================
import { Channel, ConsumeMessage } from "amqplib";
import { Event } from "../events/base-event";
export declare abstract class Listener<T extends Event> {
    abstract routingKey: T["subject"];
    abstract queueName: string;
    abstract onMessage(data: T["data"], msg: ConsumeMessage): Promise<void>;
    protected channel: Channel;
    protected exchange: string;
    constructor(channel: Channel, exchange?: string);
    listen(): Promise<void>;
}


================================================================================
File: /Users/luketchang/code/ticketing/common/build/messaging/__mocks__/rabbitmq-wrapper.d.ts
================================================================================
export declare const rabbitmqWrapper: {
    channel: {
        publish: any;
        consume: any;
        ack: any;
        nack: any;
        assertQueue: any;
        bindQueue: any;
        assertExchange: any;
        prefetch: any;
    };
    connection: {
        createChannel: any;
        close: any;
    };
    connect: any;
    close: any;
    isInitialized: boolean;
};


================================================================================
File: /Users/luketchang/code/ticketing/common/src/logger.ts
================================================================================
import winston from "winston";

const serviceName = process.env.SERVICE_NAME || "common";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: serviceName },
  transports: [new winston.transports.Console()],
});

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/common/src/index.ts
================================================================================
export * from "./errors/bad-request-error";
export * from "./errors/custom-error";
export * from "./errors/database-connection-error";
export * from "./errors/not-authorized-error";
export * from "./errors/not-found-error";
export * from "./errors/request-validation-error";

export * from "./middlewares/current-user";
export * from "./middlewares/error-handler";
export * from "./middlewares/require-auth";
export * from "./middlewares/validate-request";

// Keep the old NATS exports for backward compatibility during migration
export * from "./events/subject";
export * from "./events/base-event";
export * from "./events/base-publisher";
export * from "./events/base-listener";
export * from "./events/ticket-created-event";
export * from "./events/ticket-updated-event";
export * from "./events/order-created-event";
export * from "./events/order-cancelled-event";
export * from "./events/types/order-status";
export * from "./events/types/queue-group-names";
export * from "./events/expiration-complete-event";
export * from "./events/payment-created-event";

// Export new RabbitMQ classes and interfaces
export * from "./messaging/rabbitmq-wrapper";
// Explicitly re-export with new names to avoid conflicts
export { Publisher as RabbitMQPublisher } from "./messaging/base-publisher";
export { Listener as RabbitMQListener } from "./messaging/base-listener";

// Export OpenTelemetry tracing
export * from "./tracing";

export { logger } from "./logger";


================================================================================
File: /Users/luketchang/code/ticketing/common/src/tracing.ts
================================================================================
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { Resource } from "@opentelemetry/resources";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import {
  trace,
  context,
  SpanKind,
  SpanStatusCode,
  Span,
} from "@opentelemetry/api";
import { logger } from "./logger";

// Global tracer instance
export const tracer = trace.getTracer("ticketing-service");

let sdk: NodeSDK | undefined;

export const setupTracing = (serviceName: string) => {
  try {
    if (sdk) {
      logger.warn("Tracing already initialized");
      return;
    }

    const otlpExporter = new OTLPTraceExporter({
      url:
        process.env.OTEL_EXPORTER_OTLP_ENDPOINT ||
        "http://otel-collector:4318/v1/traces",
    });

    sdk = new NodeSDK({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
        [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]:
          process.env.NODE_ENV || "development",
      }),
      traceExporter: otlpExporter,
    });

    // Start the SDK
    sdk.start();
    logger.info("OpenTelemetry tracing initialized", { serviceName });

    // Gracefully shut down the SDK on process exit
    process.on("SIGTERM", () => {
      sdk
        ?.shutdown()
        .then(() => logger.info("OpenTelemetry SDK shut down"))
        .catch((error: Error) =>
          logger.error("Error shutting down OpenTelemetry SDK", { error })
        )
        .finally(() => process.exit(0));
    });
  } catch (error) {
    logger.error("Failed to initialize OpenTelemetry", { error });
  }
};

// Helper functions for creating messaging spans
export const createMessageProducerSpan = (
  exchange: string,
  routingKey: string,
  messageId: string
): Span => {
  return tracer.startSpan(`publish to ${exchange}`, {
    kind: SpanKind.PRODUCER,
    attributes: {
      "messaging.system": "rabbitmq",
      "messaging.destination": exchange,
      "messaging.destination_kind": "exchange",
      "messaging.rabbitmq.routing_key": routingKey,
      "messaging.message_id": messageId,
    },
  });
};

export const createMessageConsumerSpan = (
  exchange: string,
  routingKey: string,
  queue: string,
  messageId: string
): Span => {
  return tracer.startSpan(`receive from ${exchange}`, {
    kind: SpanKind.CONSUMER,
    attributes: {
      "messaging.system": "rabbitmq",
      "messaging.destination": exchange,
      "messaging.destination_kind": "exchange",
      "messaging.rabbitmq.routing_key": routingKey,
      "messaging.rabbitmq.queue": queue,
      "messaging.message_id": messageId,
    },
  });
};

// Helper to trace message processing
export const traceMessageProcessing = async <T>(
  span: Span,
  processFn: () => Promise<T>
): Promise<T> => {
  return context.with(trace.setSpan(context.active(), span), async () => {
    try {
      const result = await processFn();
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error: any) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error.message,
      });
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  });
};


================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/require-auth.ts
================================================================================
import { Request, Response, NextFunction } from 'express';

import { NotAuthorizedError } from '../errors/not-authorized-error';

export const requireAuth = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    if(!req.currentUser) {
        throw new NotAuthorizedError();
    }

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/validate-request.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';

import { RequestValidationError } from '../errors/request-validation-error';

export const validateRequest = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const errors = validationResult(req); 
    if(!errors.isEmpty()) {
        throw new RequestValidationError(errors.array());
    }

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/error-handler.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../errors/custom-error';

export const errorHandler = (
    err: Error, 
    req: Request, 
    res: Response, 
    next: NextFunction
) => {
    if(err instanceof CustomError) {
        return res.status(err.statusCode).send({ errors: err.serializeErrors() });
    }

    console.error(err);
    res.status(400).send({
        errors: [{ message: 'Something went wrong.' }]
    });
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/middlewares/current-user.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface UserPayload {
    id: string;
    email: string;
}

declare global {
    namespace Express {
        interface Request {
            currentUser?: UserPayload;
        }
    }
}

export const currentUser = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    if(!req.session?.jwt) {
        return next();
    }

    try {
        const payload = jwt.verify(req.session.jwt, process.env.JWT_KEY!) as UserPayload;
        req.currentUser = payload;
    } catch(_) {}

    next();
};

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/bad-request-error.ts
================================================================================
import { CustomError } from './custom-error';

export class BadRequestError extends CustomError {
    constructor(public message: string) {
        super(message);
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }

    statusCode = 400;
    serializeErrors() {
        return [
            { message: this.message }
        ]
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/database-connection-error.ts
================================================================================
import { CustomError } from "./custom-error";

export class DatabaseConnectionError extends CustomError {
    constructor() {
        super('Database Connection Error');
        Object.setPrototypeOf(this, DatabaseConnectionError.prototype)
    }

    statusCode = 500;
    reason = 'Error connecting to database.';
    serializeErrors() {
        return [
            { message: this.reason }
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/not-authorized-error.ts
================================================================================
import { CustomError } from './custom-error';

export class NotAuthorizedError extends CustomError {
    constructor() {
        super('Not authorized.');
        Object.setPrototypeOf(this, NotAuthorizedError.prototype);
    }

    statusCode = 401;
    serializeErrors() {
        return [
            { message: 'User not authorized.' }
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/request-validation-error.ts
================================================================================
import { ValidationError } from 'express-validator';
import { CustomError } from './custom-error';

export class RequestValidationError extends CustomError {
    constructor(public errors: ValidationError[]) {
        super('Request Validation Error');
        Object.setPrototypeOf(this, RequestValidationError.prototype);
    }

    statusCode = 400;
    serializeErrors() {
        return this.errors.map(err => {
            return {
                message: err.msg,
                field: err.param
            }
        });
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/custom-error.ts
================================================================================
export abstract class CustomError extends Error {
    abstract statusCode: number;
    abstract serializeErrors(): { message: string, field?: string }[];

    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, CustomError.prototype);
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/errors/not-found-error.ts
================================================================================
import { CustomError } from './custom-error';

export class NotFoundError extends CustomError {
    constructor() {
        super('Not Found Error');
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }

    statusCode = 404;
    serializeErrors() {
        return [
            { message: 'Not found.'}
        ];
    }
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/payment-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface PaymentCreatedEvent extends Event {
    subject: Subject.PaymentCreated;
    data: {
        id: string;
        orderId: string;
        stripeId: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/order-cancelled-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface OrderCancelledEvent extends Event {
    subject: Subject.OrderCancelled;
    data: {
        id: string;
        version: number;
        ticket: {
            id: string;
        };
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-publisher.ts
================================================================================
import { Stan } from "node-nats-streaming";
import { Event } from "./base-event";
import { logger } from "../logger";

export abstract class Publisher<T extends Event> {
  abstract subject: T["subject"];
  protected client: Stan;

  constructor(client: Stan) {
    this.client = client;
  }

  publish(data: T["data"]): Promise<void> {
    return new Promise((resolve, reject) => {
      this.client.publish(this.subject, JSON.stringify(data), (err) => {
        if (err) {
          logger.error("Error publishing event", {
            subject: this.subject,
            error: err,
          });
          return reject(err);
        }

        logger.info("Event published", { subject: this.subject, data });
        resolve();
      });
    });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-event.ts
================================================================================
import { Subject } from './subject';

export interface Event {
    subject: Subject;
    data: any;
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/expiration-complete-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface ExpirationCompleteEvent extends Event {
    subject: Subject.ExpirationComplete;
    data: {
        orderId: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/ticket-updated-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface TicketUpdatedEvent extends Event {
    subject: Subject.TicketUpdated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
        orderId?: string;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/subject.ts
================================================================================
export enum Subject {
    TicketCreated = 'ticket:created',
    TicketUpdated = 'ticket:updated',

    OrderCreated = 'order:created',
    OrderCancelled = 'order:cancelled',

    ExpirationComplete = 'expiration:complete',

    PaymentCreated = 'payment:created'
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/base-listener.ts
================================================================================
import { Message, Stan } from "node-nats-streaming";
import { Event } from "./base-event";
import { logger } from "../logger";
import tracer from "dd-trace";

export abstract class Listener<T extends Event> {
  abstract subject: T["subject"];
  abstract queueGroupName: string;
  abstract onMessage(data: T["data"], msg: Message): void;
  protected client: Stan;
  protected ackWait = 5 * 1000;

  constructor(client: Stan) {
    this.client = client;
  }

  subscriptionOptions() {
    return this.client
      .subscriptionOptions()
      .setDeliverAllAvailable()
      .setManualAckMode(true)
      .setAckWait(this.ackWait)
      .setDurableName(this.queueGroupName);
  }

  listen() {
    const subscription = this.client.subscribe(
      this.subject,
      this.queueGroupName,
      this.subscriptionOptions()
    );

    subscription.on("message", async (msg: Message) => {
      logger.info(
        `Message received: ${this.subject} / ${this.queueGroupName}`,
        { subject: this.subject, queueGroupName: this.queueGroupName }
      );

      const parsedData = this.parseMessage(msg);

      // Create a parent span for this NATS message
      const messageSpan = tracer.startSpan("nats.message_processing", {
        tags: {
          "resource.name": `${this.subject}-${this.queueGroupName}`,
          "service.name": process.env.SERVICE_NAME || "unknown-service",
          "span.kind": "consumer",
          "messaging.system": "nats",
          "messaging.destination": this.subject,
          "messaging.destination_kind": "topic",
          "messaging.operation": "process",
          "span.type": "worker",
        },
      });

      messageSpan.setTag("message.id", msg.getSequence());
      messageSpan.setTag("messaging.queue", this.queueGroupName);

      // This special format helps Datadog identify this as an entry point similar to HTTP
      messageSpan.setTag("component", "nats");
      messageSpan.setTag("peer.service", "nats");

      // Create a root span that will be the parent of all database operations
      // This mimics how web requests create a root span
      const rootSpan = tracer.startSpan("nats.handler", {
        childOf: messageSpan,
        tags: {
          "resource.name": `${this.subject}-${this.queueGroupName}`,
          "service.name": process.env.SERVICE_NAME || "unknown-service",
          "span.type": "custom",
        },
      });

      // Set this span as the active span for the duration of this message processing
      // This is the key part - it ensures all internal operations become child spans
      tracer.scope().activate(rootSpan, async () => {
        try {
          // Process the message inside this trace context
          this.onMessage(parsedData, msg);

          // If successful, acknowledge the message
          msg.ack();

          // You can add a success tag
          rootSpan.setTag("message.status", "acknowledged");
          messageSpan.setTag("message.status", "acknowledged");
        } catch (error: any) {
          // Log the error
          logger.error(`Error processing message: ${this.subject}`, {
            subject: this.subject,
            queueGroupName: this.queueGroupName,
            error: error.message,
            stack: error.stack,
          });

          // Mark both spans as errors
          rootSpan.setTag("error", true);
          rootSpan.setTag("error.message", error.message);
          rootSpan.setTag("error.type", error.constructor.name || "Error");
          if (error.stack) {
            rootSpan.setTag("error.stack", error.stack);
          }

          messageSpan.setTag("error", true);
          messageSpan.setTag("error.message", error.message);

          // Add a failure status
          rootSpan.setTag("message.status", "failed");
          messageSpan.setTag("message.status", "failed");

          // Still acknowledge the message to prevent redelivery
          // You might want to customize this behavior based on the error type
          msg.ack();
        } finally {
          // Make sure to finish the spans in the right order
          rootSpan.finish();
          messageSpan.finish();
        }
      });
    });
  }

  parseMessage(msg: Message) {
    const data = msg.getData();
    return typeof data === "string"
      ? JSON.parse(data)
      : JSON.parse(data.toString("utf8"));
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/ticket-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';

export interface TicketCreatedEvent extends Event {
    subject: Subject.TicketCreated;
    data: {
        id: string;
        title: string;
        price: number;
        userId: string;
        version: number;
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/order-created-event.ts
================================================================================
import { Subject } from './subject';
import { Event } from './base-event';
import { OrderStatus } from './types/order-status';

export interface OrderCreatedEvent extends Event {
    subject: Subject.OrderCreated;
    data: {
        id: string;
        status: OrderStatus;
        userId: string;
        expiresAt: string;
        version: number;
        ticket: {
            id: string;
            price: number;
        };
    };
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/types/order-status.ts
================================================================================
export enum OrderStatus {
    Created = 'created',
    Cancelled = 'cancelled', //catch all
    AwaitingPayment = 'awaiting:payment',
    Complete = 'complete'
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/events/types/queue-group-names.ts
================================================================================
export enum QueueGroupName {
    OrdersService = 'orders-service',
    TicketsService = 'tickets-service',
    PaymentsService = 'payments-service',
    ExpirationService = 'expiration-service'
}

================================================================================
File: /Users/luketchang/code/ticketing/common/src/messaging/base-publisher.ts
================================================================================
import { Channel } from "amqplib";
import { Event } from "../events/base-event";
import { logger } from "../logger";
import { v4 as uuid } from "uuid";
import { createMessageProducerSpan } from "../tracing";

export abstract class Publisher<T extends Event> {
  abstract routingKey: T["subject"];
  protected channel: Channel;
  protected exchange: string;

  constructor(channel: Channel, exchange: string = "ticketing") {
    this.channel = channel;
    this.exchange = exchange;
  }

  async publish(data: T["data"]): Promise<void> {
    try {
      // Generate a unique message ID for tracking
      const messageId = uuid();

      // Create a span for this publish operation
      const span = createMessageProducerSpan(
        this.exchange,
        this.routingKey,
        messageId
      );

      try {
        // Convert data to buffer
        const message = Buffer.from(JSON.stringify(data));

        // Add OpenTelemetry trace context to message headers
        const options = {
          persistent: true,
          messageId,
          headers: {
            "x-message-id": messageId,
          },
        };

        // Publish the message
        this.channel.publish(this.exchange, this.routingKey, message, options);

        logger.info("Event published", {
          exchange: this.exchange,
          routingKey: this.routingKey,
          messageId,
          data,
        });

        // Mark span as successful
        span.setStatus({ code: 0 });
      } catch (error: any) {
        // Record error in span
        span.recordException(error);
        span.setStatus({ code: 1, message: error.message });
        throw error;
      } finally {
        // End the span
        span.end();
      }
    } catch (error: any) {
      logger.error("Error publishing event", {
        exchange: this.exchange,
        routingKey: this.routingKey,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/messaging/rabbitmq-wrapper.ts
================================================================================
import * as amqplib from "amqplib";
import { logger } from "../logger";

// Define the interfaces
export interface RabbitMQConfig {
  url: string;
  exchanges: ExchangeConfig[];
}

export interface ExchangeConfig {
  name: string;
  type: string;
  options?: amqplib.Options.AssertExchange;
}

export class RabbitMQWrapper {
  private _connection?: amqplib.Connection;
  private _channel?: amqplib.Channel;
  private _config: RabbitMQConfig;
  private _initialized = false;

  constructor(config: RabbitMQConfig) {
    this._config = config;
  }

  get channel(): amqplib.Channel {
    if (!this._channel) {
      throw new Error("Cannot access RabbitMQ channel before connecting");
    }
    return this._channel;
  }

  get connection(): amqplib.Connection {
    if (!this._connection) {
      throw new Error("Cannot access RabbitMQ connection before connecting");
    }
    return this._connection;
  }

  get isInitialized(): boolean {
    return this._initialized;
  }

  async connect(): Promise<void> {
    try {
      logger.info("Connecting to RabbitMQ", { url: this._config.url });

      // Using unknown as intermediate type to bypass TypeScript's type checking
      // The amqplib types are not correctly defined but the library works as expected
      const connection = (await amqplib.connect(
        this._config.url
      )) as unknown as amqplib.Connection;
      this._connection = connection;

      // Set up reconnection logic
      connection.on("error", (err: Error) => {
        logger.error("RabbitMQ connection error", { error: err.message });
        this._initialized = false;
      });

      connection.on("close", () => {
        logger.warn("RabbitMQ connection closed");
        this._initialized = false;

        // Try to reconnect after a delay
        setTimeout(() => {
          if (!this._initialized) {
            logger.info("Attempting to reconnect to RabbitMQ");
            this.connect().catch((err: Error) => {
              logger.error("Failed to reconnect to RabbitMQ", {
                error: err.message,
              });
            });
          }
        }, 5000);
      });

      // Create a channel - using unknown as intermediate type to bypass TypeScript's type checking
      const channel = (await (
        connection as any
      ).createChannel()) as amqplib.Channel;
      this._channel = channel;

      // Set up channel error handling
      channel.on("error", (err: Error) => {
        logger.error("RabbitMQ channel error", { error: err.message });
      });

      channel.on("close", () => {
        logger.warn("RabbitMQ channel closed");
      });

      // Set prefetch count to limit the number of unacknowledged messages
      await channel.prefetch(1);

      // Set up exchanges
      for (const exchange of this._config.exchanges) {
        await channel.assertExchange(
          exchange.name,
          exchange.type,
          exchange.options || { durable: true }
        );
        logger.info("RabbitMQ exchange asserted", { exchange: exchange.name });
      }

      this._initialized = true;
      logger.info("Connected to RabbitMQ successfully");
    } catch (error: any) {
      logger.error("Error connecting to RabbitMQ", { error: error.message });
      throw error;
    }
  }

  async close(): Promise<void> {
    try {
      if (this._channel) {
        await this._channel.close();
        this._channel = undefined;
      }

      if (this._connection) {
        // Using any to bypass TypeScript type checking
        await (this._connection as any).close();
        this._connection = undefined;
      }

      this._initialized = false;
      logger.info("RabbitMQ connection closed successfully");
    } catch (error: any) {
      logger.error("Error closing RabbitMQ connection", {
        error: error.message,
      });
      throw error;
    }
  }
}

// Default RabbitMQ configuration based on our event types
export const defaultRabbitMQConfig: RabbitMQConfig = {
  url: process.env.RABBITMQ_URL || "amqp://guest:guest@rabbitmq-srv:5672",
  exchanges: [
    {
      name: "ticketing",
      type: "topic",
      options: {
        durable: true,
      },
    },
  ],
};

// Singleton instance
export const rabbitmqWrapper = new RabbitMQWrapper(defaultRabbitMQConfig);


================================================================================
File: /Users/luketchang/code/ticketing/common/src/messaging/base-listener.ts
================================================================================
import { Channel, ConsumeMessage } from "amqplib";
import { Event } from "../events/base-event";
import { logger } from "../logger";
import { createMessageConsumerSpan, traceMessageProcessing } from "../tracing";

export abstract class Listener<T extends Event> {
  abstract routingKey: T["subject"];
  abstract queueName: string;
  abstract onMessage(data: T["data"], msg: ConsumeMessage): Promise<void>;

  protected channel: Channel;
  protected exchange: string;

  constructor(channel: Channel, exchange: string = "ticketing") {
    this.channel = channel;
    this.exchange = exchange;
  }

  async listen(): Promise<void> {
    try {
      // Assert the queue
      await this.channel.assertQueue(this.queueName, {
        durable: true,
        // Auto-delete: false - queue will not be deleted when last consumer unsubscribes
        autoDelete: false,
      });

      // Bind the queue to the exchange with routing key
      await this.channel.bindQueue(
        this.queueName,
        this.exchange,
        this.routingKey
      );

      logger.info("Queue bound to exchange", {
        queue: this.queueName,
        exchange: this.exchange,
        routingKey: this.routingKey,
      });

      // Start consuming messages
      await this.channel.consume(
        this.queueName,
        async (msg) => {
          if (!msg) {
            logger.warn("Received null message", {
              queue: this.queueName,
              exchange: this.exchange,
              routingKey: this.routingKey,
            });
            return;
          }

          try {
            // Parse the message
            const messageContent = msg.content.toString();
            const data = JSON.parse(messageContent);

            // Get the message ID from headers or generate one
            const messageId =
              msg.properties.messageId ||
              (msg.properties.headers &&
                msg.properties.headers["x-message-id"]) ||
              "unknown";

            logger.info("Message received", {
              exchange: this.exchange,
              routingKey: this.routingKey,
              queue: this.queueName,
              messageId,
            });

            // Create a consumer span
            const span = createMessageConsumerSpan(
              this.exchange,
              this.routingKey,
              this.queueName,
              messageId
            );

            // Process the message within the tracing context
            await traceMessageProcessing(span, async () => {
              await this.onMessage(data, msg);
            });

            // Acknowledge the message
            this.channel.ack(msg);

            logger.info("Message acknowledged", {
              exchange: this.exchange,
              routingKey: this.routingKey,
              queue: this.queueName,
              messageId,
            });
          } catch (error: any) {
            logger.error("Error processing message", {
              exchange: this.exchange,
              routingKey: this.routingKey,
              queue: this.queueName,
              error: error.message,
              stack: error.stack,
            });

            // Reject the message and requeue it if possible
            // This can lead to an infinite loop if the message is always failing
            // Consider implementing a dead letter exchange for better error handling
            this.channel.nack(msg, false, false);
          }
        },
        {
          // Manual acknowledgment required
          noAck: false,
        }
      );

      logger.info("Listening for messages", {
        exchange: this.exchange,
        routingKey: this.routingKey,
        queue: this.queueName,
      });
    } catch (error: any) {
      logger.error("Error setting up listener", {
        exchange: this.exchange,
        routingKey: this.routingKey,
        queue: this.queueName,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/common/src/messaging/__mocks__/rabbitmq-wrapper.ts
================================================================================
// Mock for the RabbitMQ wrapper to be used in tests
import { Channel, ConsumeMessage } from "amqplib";

// Simple mock function that can be used in place of jest.fn()
function createMockFn(implementation?: any) {
  const fn = implementation || (() => {});
  fn.mockImplementation = (impl: any) => {
    Object.assign(fn, impl);
    return fn;
  };
  fn.mockResolvedValue = (value: any) => {
    fn.mockImplementation = () => Promise.resolve(value);
    return fn;
  };
  return fn;
}

export const rabbitmqWrapper = {
  channel: {
    // Mock for publish method
    publish: createMockFn(
      (exchange: string, routingKey: string, content: Buffer, options: any) =>
        true
    ),

    // Mock for consume method
    consume: createMockFn(() =>
      Promise.resolve({ consumerTag: "mock-consumer" })
    ),

    // Mock for ack method
    ack: createMockFn((msg: any) => {}),

    // Mock for nack method
    nack: createMockFn((msg: any, allUpTo: boolean, requeue: boolean) => {}),

    // Mock for assertQueue method
    assertQueue: createMockFn(() =>
      Promise.resolve({
        queue: "mock-queue",
        messageCount: 0,
        consumerCount: 0,
      })
    ),

    // Mock for bindQueue method
    bindQueue: createMockFn(() => Promise.resolve({})),

    // Mock for assertExchange method
    assertExchange: createMockFn(() =>
      Promise.resolve({ exchange: "mock-exchange" })
    ),

    // Mock for prefetch method
    prefetch: createMockFn(() => Promise.resolve({})),
  },

  connection: {
    // Mock for createChannel method
    createChannel: createMockFn(() => Promise.resolve({} as Channel)),

    // Mock for close method
    close: createMockFn(() => Promise.resolve()),
  },

  // Mock for connect method
  connect: createMockFn(() => Promise.resolve()),

  // Mock for close method
  close: createMockFn(() => Promise.resolve()),

  // Property to track if connected
  isInitialized: true,
};


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/tracer.ts
================================================================================
import { setupTracing } from "@lt-ticketing/common";

// Initialize OpenTelemetry tracing for this service
setupTracing("expiration-service");


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/rabbitmq-wrapper.ts
================================================================================
import { RabbitMQWrapper, defaultRabbitMQConfig } from "@lt-ticketing/common";

// Re-export the rabbitmqWrapper instance from common
export const rabbitmqWrapper = new RabbitMQWrapper({
  ...defaultRabbitMQConfig,
  // Override URL if needed
  url: process.env.RABBITMQ_URL || "amqp://guest:guest@rabbitmq-srv:5672",
  // Add any service-specific exchanges if needed
  exchanges: [
    ...defaultRabbitMQConfig.exchanges,
    // Add service-specific exchanges here if needed
  ],
});


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "expiration" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/index.ts
================================================================================
import "./tracer";
import { OrderCreatedListener } from "./events/listeners/order-created-listener";
import { rabbitmqWrapper } from "./rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  // Validate environment variables
  if (!process.env.RABBITMQ_URL) {
    throw new Error("RABBITMQ_URL not defined.");
  }

  try {
    // Connect to RabbitMQ
    await rabbitmqWrapper.connect();

    logger.info("Connected to RabbitMQ", {
      url: process.env.RABBITMQ_URL,
    });

    // Handle graceful shutdown
    process.on("SIGINT", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    process.on("SIGTERM", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    // Start the listener
    new OrderCreatedListener(rabbitmqWrapper.channel).listen();

    logger.info("Expiration service started successfully");
  } catch (err) {
    logger.error("Error starting the application", { error: err });
    process.exit(1);
  }
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/queues/expiration-queue.ts
================================================================================
import Queue from "bull";

import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { ExpirationCompletePublisher } from "../events/publishers/expiration-complete-publisher";
import { logger } from "@lt-ticketing/common";

interface Payload {
  orderId: string;
}

const expirationQueue = new Queue<Payload>("order:expiration", {
  redis: {
    host: process.env.REDIS_HOST,
  },
});

expirationQueue.process(async (job) => {
  logger.info(
    `Publishing expiration:complete event for orderId ${job.data.orderId}`
  );

  // Create a new publisher with the RabbitMQ channel
  await new ExpirationCompletePublisher(rabbitmqWrapper.channel).publish({
    orderId: job.data.orderId,
  });
});

export { expirationQueue };


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/events/publishers/expiration-complete-publisher.ts
================================================================================
import {
  RabbitMQPublisher,
  ExpirationCompleteEvent,
  Subject,
} from "@lt-ticketing/common";

export class ExpirationCompletePublisher extends RabbitMQPublisher<ExpirationCompleteEvent> {
  routingKey: Subject.ExpirationComplete = Subject.ExpirationComplete;
}


================================================================================
File: /Users/luketchang/code/ticketing/expiration/src/events/listeners/order-created-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  Subject,
  OrderCreatedEvent,
  QueueGroupName,
  RabbitMQListener,
} from "@lt-ticketing/common";
import { expirationQueue } from "../../queues/expiration-queue";
import { logger } from "@lt-ticketing/common";

export class OrderCreatedListener extends RabbitMQListener<OrderCreatedEvent> {
  routingKey: Subject.OrderCreated = Subject.OrderCreated;
  queueName = QueueGroupName.ExpirationService;

  async onMessage(
    data: OrderCreatedEvent["data"],
    msg: ConsumeMessage
  ): Promise<void> {
    logger.info("Order created event received", { data });
    const delay = new Date(data.expiresAt).getTime() - new Date().getTime();

    logger.info("Order expires in milliseconds.", { delay, data });
    await expirationQueue.add(
      {
        orderId: data.id,
      },
      {
        delay,
      }
    );

    logger.info("Order added to expiration queue", { data });

    logger.info("Order created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/nats-wrapper.ts
================================================================================
import nats, { Stan } from 'node-nats-streaming';

class NatsWrapper {
    private _client?: Stan;
    
    get client() {
        if(!this._client) throw new Error('Cannot connect to NATS client before it is initialized.');
        return this._client!;
    }

    connect(clusterId: string, clientId: string, url: string) {
        this._client = nats.connect(clusterId, clientId, { url });
        return new Promise<void>((resolve, reject) => {
            this.client.on('connect', () => {
                console.log('Connected to NATS.');
                resolve();
            })

            this.client.on('error', (err) => {
                reject(err);
            })
        });
    }
}

export const natsWrapper = new NatsWrapper();


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/tracer.ts
================================================================================
import { setupTracing } from "@lt-ticketing/common";

// Initialize OpenTelemetry tracing for this service
setupTracing("orders-service");


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/app.ts
================================================================================
import express from 'express';
import 'express-async-errors';
import { json } from 'body-parser';
import cookieSession from 'cookie-session';
import { errorHandler, NotFoundError, currentUser } from '@lt-ticketing/common';

import { indexOrderRouter } from './routes/index';
import { newOrderRouter } from './routes/new';
import { showOrderRouter } from './routes/show';
import { deleteOrderRouter } from './routes/delete';


const app = express();
app.set('trust proxy', true);
app.use(json());
app.use(
    cookieSession({
        signed: false,
        secure: process.env.NODE_ENV !== 'test'
    })
);
app.use(currentUser);

app.use(indexOrderRouter);
app.use(newOrderRouter);
app.use(showOrderRouter);
app.use(deleteOrderRouter);

app.all('*', async (req, res) => {
    throw new NotFoundError();
})

app.use(errorHandler);

export { app };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/rabbitmq-wrapper.ts
================================================================================
import { RabbitMQWrapper, defaultRabbitMQConfig } from "@lt-ticketing/common";

// Re-export the rabbitmqWrapper instance from common
export const rabbitmqWrapper = new RabbitMQWrapper({
  ...defaultRabbitMQConfig,
  // Override URL if needed
  url: process.env.RABBITMQ_URL || "amqp://guest:guest@rabbitmq-srv:5672",
  // Add any service-specific exchanges if needed
  exchanges: [
    ...defaultRabbitMQConfig.exchanges,
    // Add service-specific exchanges here if needed
  ],
}); 

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/logger.ts
================================================================================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  defaultMeta: { service: "orders" },
  transports: [new winston.transports.Console()],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

export { logger };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/index.ts
================================================================================
import "./tracer";
import mongoose from "mongoose";

import { app } from "./app";
import { rabbitmqWrapper } from "./rabbitmq-wrapper";
import { TicketCreatedListener } from "./events/listeners/ticket-created-listener";
import { TicketUpdatedListener } from "./events/listeners/ticket-updated-listener";
import { ExpirationCompleteListener } from "./events/listeners/expiration-complete-listener";
import { PaymentCreatedListener } from "./events/listeners/payment-created-listener";
import { logger } from "@lt-ticketing/common";

const start = async () => {
  if (!process.env.JWT_KEY) throw new Error("JWT_KEY not defined.");
  if (!process.env.ORDERS_MONGO_URI)
    throw new Error("ORDERS_MONGO_URI not defined.");
  if (!process.env.RABBITMQ_URL) throw new Error("RABBITMQ_URL not defined.");

  try {
    // Connect to RabbitMQ
    await rabbitmqWrapper.connect();
    logger.info("Connected to RabbitMQ", {
      url: process.env.RABBITMQ_URL,
    });

    // Handle graceful shutdown
    process.on("SIGINT", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    process.on("SIGTERM", async () => {
      await rabbitmqWrapper.close();
      process.exit(0);
    });

    // Initialize listeners
    new TicketCreatedListener(rabbitmqWrapper.channel).listen();
    new TicketUpdatedListener(rabbitmqWrapper.channel).listen();
    new ExpirationCompleteListener(rabbitmqWrapper.channel).listen();
    new PaymentCreatedListener(rabbitmqWrapper.channel).listen();

    logger.info("Listeners started");

    // Connect to MongoDB
    await mongoose.connect(process.env.ORDERS_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true,
    });
    logger.info("Connected to MongoDB");

    app.listen(3000, () => {
      logger.info("Orders service listening on port 3000!");
    });
  } catch (err) {
    logger.error("Error during startup", { error: err });
    process.exit(1);
  }
};

start();


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/__mocks__/nats-wrapper.ts
================================================================================
export const natsWrapper = {
    client: {
        publish: jest
            .fn()
            .mockImplementation((subject: string, data: string, callback: () => void) => {
                callback();
            })
    }
};

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/__mocks__/rabbitmq-wrapper.ts
================================================================================
// Mock for the RabbitMQ wrapper to be used in tests
export const rabbitmqWrapper = {
  channel: {
    publish: jest.fn().mockImplementation(() => {}),
    assertExchange: jest.fn().mockResolvedValue({}),
    assertQueue: jest.fn().mockResolvedValue({}),
    bindQueue: jest.fn().mockResolvedValue({}),
    consume: jest.fn().mockResolvedValue({}),
    prefetch: jest.fn().mockResolvedValue({}),
    ack: jest.fn().mockImplementation(() => {}),
    nack: jest.fn().mockImplementation(() => {}),
  },
  connect: jest.fn().mockResolvedValue({}),
  close: jest.fn().mockResolvedValue({}),
  isInitialized: true,
};


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/getAuthCookie.ts
================================================================================
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

export const getAuthCookie = () => {
    const id = mongoose.Types.ObjectId().toHexString();
    const password = 'password';
    const payload = {
        id,
        password
    };

    const token = jwt.sign(payload, process.env.JWT_KEY!);
    const session = { jwt: token };
    const sessionJson = JSON.stringify(session);
    const base64 = Buffer.from(sessionJson).toString('base64');
    return [`express:sess=${base64}`];
};

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/createOrder.ts
================================================================================
import request from 'supertest';
import { app } from '../app';
import { TicketDoc } from '../models/ticket'

export const createOrder = async (ticket: TicketDoc, cookie: string[]) => {
    const res = await request(app)
        .post('/api/orders')
        .set('Cookie', cookie)
        .send({ ticketId: ticket.id })
        .expect(201);
    
    return res;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/setup.ts
================================================================================
import { MongoMemoryServer } from "mongodb-memory-server";
import mongoose from "mongoose";

jest.mock("../rabbitmq-wrapper");

let mongo: any;
beforeAll(async () => {
  process.env.JWT_KEY = "JWT_TEST_KEY";

  mongo = new MongoMemoryServer();
  const mongoUri = await mongo.getUri();

  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

beforeEach(async () => {
  jest.clearAllMocks();
  const collections = await mongoose.connection.db.collections();
  for (let collection of collections) {
    await collection.deleteMany({});
  }
});

afterAll(async () => {
  await mongo.stop();
  await mongoose.connection.close();
});


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/test/createTicket.ts
================================================================================
import mongoose from 'mongoose';
import { Ticket } from '../models/ticket';

export const createTicket = async () => {
    const ticket = Ticket.build({
        id: mongoose.Types.ObjectId().toHexString(),
        title: 'concert',
        price: 20
    });
    await ticket.save();
    return ticket;
}

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/models/order.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { TicketDoc } from './ticket';
import { OrderStatus } from '@lt-ticketing/common';

interface OrderAttrs {
    userId: string;
    status: OrderStatus;
    expiresAt: Date;
    ticket: TicketDoc;
}

interface OrderDoc extends mongoose.Document {
    userId: string;
    status: OrderStatus;
    expiresAt: Date;
    version: number;
    ticket: TicketDoc;
}

interface OrderModel extends mongoose.Model<OrderDoc> {
    build(attrs: OrderAttrs): OrderDoc;
}

const orderSchema = new mongoose.Schema ({
    userId: {
        type: String,
        required: true
    },
    status: {
        type: String,
        required: true,
        enum: Object.values(OrderStatus),
        default: OrderStatus.Created
    },
    expiresAt: {
        type: mongoose.Schema.Types.Date,
        required: false
    },
    ticket: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Ticket'
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

orderSchema.set('versionKey', 'version');
orderSchema.plugin(updateIfCurrentPlugin);

orderSchema.statics.build = (attrs: OrderAttrs) => {
    return new Order(attrs);
}

const Order = mongoose.model<OrderDoc, OrderModel>('Order', orderSchema);

export { Order };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/models/ticket.ts
================================================================================
import mongoose from 'mongoose';
import { updateIfCurrentPlugin } from 'mongoose-update-if-current';

import { Order } from './order';
import { OrderStatus } from '@lt-ticketing/common';
import { idText } from 'typescript';

interface TicketAttrs {
    id: string;
    title: string;
    price: number;
}

export interface TicketDoc extends mongoose.Document {
    title: string;
    price: number;
    version: number;
    isReserved(): Promise<boolean>;
}

interface TicketModel extends mongoose.Model<TicketDoc> {
    build(attrs: TicketAttrs): TicketDoc;
    findByEvent(data: { id: string, version: number}): Promise<TicketDoc | null>
}

const ticketSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true,
        min: 0
    }
}, {
    toJSON: {
        transform(doc, ret) {
            ret.id = ret._id;
            delete ret._id;
        }
    }
});

ticketSchema.set('versionKey', 'version');
ticketSchema.plugin(updateIfCurrentPlugin);

ticketSchema.statics.build = (attrs: TicketAttrs) => {
    return new Ticket({
        _id: attrs.id,
        title: attrs.title,
        price: attrs.price
    });
}

ticketSchema.statics.findByEvent = (data: { id: string, version: number}) => {
    return Ticket.findOne({
        _id: data.id,
        version: data.version - 1
    });
}

ticketSchema.methods.isReserved = async function() {
    const existingOrder = Order.findOne({
        ticket: this as TicketDoc,
        status: {
            $in: [
                OrderStatus.Created,
                OrderStatus.AwaitingPayment,
                OrderStatus.Complete
            ]
        }
    });

    return !existingOrder;
}

const Ticket = mongoose.model<TicketDoc, TicketModel>('Ticket', ticketSchema);

export { Ticket };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/publishers/order-created-publisher.ts
================================================================================
import {
  Subject,
  RabbitMQPublisher,
  OrderCreatedEvent,
} from "@lt-ticketing/common";

export class OrderCreatedPublisher extends RabbitMQPublisher<OrderCreatedEvent> {
  routingKey: Subject.OrderCreated = Subject.OrderCreated;
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/publishers/order-cancelled-publisher.ts
================================================================================
import {
  Subject,
  RabbitMQPublisher,
  OrderCancelledEvent,
} from "@lt-ticketing/common";

export class OrderCancelledPublisher extends RabbitMQPublisher<OrderCancelledEvent> {
  routingKey: Subject.OrderCancelled = Subject.OrderCancelled;
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/ticket-updated-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  Subject,
  QueueGroupName,
  TicketUpdatedEvent,
  RabbitMQListener,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { logger } from "@lt-ticketing/common";

export class TicketUpdatedListener extends RabbitMQListener<TicketUpdatedEvent> {
  routingKey: Subject.TicketUpdated = Subject.TicketUpdated;
  queueName = QueueGroupName.OrdersService;

  async onMessage(data: TicketUpdatedEvent["data"], msg: ConsumeMessage) {
    logger.info("Ticket updated event received", { data });

    const ticket = await Ticket.findByEvent(data);

    if (!ticket) {
      logger.warn("Ticket not found", { data });
      throw new Error("Ticket not found.");
    }

    const { title, price } = data;
    ticket.set({ title, price });
    await ticket.save();

    logger.info("Ticket updated", { data });

    // Acknowledgment is handled by the base listener class

    logger.info("Ticket updated event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/ticket-created-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  Subject,
  QueueGroupName,
  TicketCreatedEvent,
  RabbitMQListener,
} from "@lt-ticketing/common";
import { Ticket } from "../../models/ticket";
import { logger } from "@lt-ticketing/common";

export class TicketCreatedListener extends RabbitMQListener<TicketCreatedEvent> {
  routingKey: Subject.TicketCreated = Subject.TicketCreated;
  queueName = QueueGroupName.OrdersService;

  async onMessage(data: TicketCreatedEvent["data"], msg: ConsumeMessage) {
    logger.info("Ticket created event received", { data });
    const { id, title, price } = data;
    const ticket = Ticket.build({ id, title, price });
    await ticket.save();

    logger.info("Ticket created", { data });

    // Acknowledgment is handled by the base listener class

    logger.info("Ticket created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/expiration-complete-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  Subject,
  ExpirationCompleteEvent,
  RabbitMQListener,
  QueueGroupName,
  OrderStatus,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { OrderCancelledPublisher } from "../publishers/order-cancelled-publisher";
import { rabbitmqWrapper } from "../../rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

export class ExpirationCompleteListener extends RabbitMQListener<ExpirationCompleteEvent> {
  routingKey: Subject.ExpirationComplete = Subject.ExpirationComplete;
  queueName = QueueGroupName.OrdersService;

  async onMessage(data: ExpirationCompleteEvent["data"], msg: ConsumeMessage) {
    logger.info("Expiration complete event received", { data });

    const order = await Order.findById(data.orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found");
    }

    if (order.status === OrderStatus.Complete) {
      logger.info("Order is already complete, skipping cancellation", { data });
      return;
    }

    order.set({ status: OrderStatus.Cancelled });
    await order.save();

    logger.info("Order cancelled due to expiration", {
      orderId: order.id,
      status: order.status,
    });

    // Publish order cancelled event
    await new OrderCancelledPublisher(rabbitmqWrapper.channel).publish({
      id: order.id,
      version: order.version,
      ticket: {
        id: order.ticket.id,
      },
    });

    logger.info("Order cancelled event published", { data });

    // Acknowledgment is handled by the base listener class

    logger.info("Expiration complete event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/events/listeners/payment-created-listener.ts
================================================================================
import { ConsumeMessage } from "amqplib";
import {
  Subject,
  PaymentCreatedEvent,
  RabbitMQListener,
  QueueGroupName,
  OrderStatus,
} from "@lt-ticketing/common";
import { Order } from "../../models/order";
import { logger } from "@lt-ticketing/common";

export class PaymentCreatedListener extends RabbitMQListener<PaymentCreatedEvent> {
  routingKey: Subject.PaymentCreated = Subject.PaymentCreated;
  queueName = QueueGroupName.OrdersService;

  async onMessage(data: PaymentCreatedEvent["data"], msg: ConsumeMessage) {
    logger.info("Payment created event received", { data });

    const order = await Order.findById(data.orderId);

    if (!order) {
      logger.warn("Order not found", { data });
      throw new Error("Order not found");
    }

    order.set({ status: OrderStatus.Complete });
    await order.save();

    logger.info("Order marked as complete", {
      orderId: order.id,
      status: order.status,
    });

    // Acknowledgment is handled by the base listener class

    logger.info("Payment created event acknowledged", { data });
  }
}


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/new.ts
================================================================================
import mongoose from "mongoose";
import express, { Request, Response } from "express";
import { body } from "express-validator";
import { Ticket } from "../models/ticket";
import { Order } from "../models/order";
import {
  requireAuth,
  validateRequest,
  NotFoundError,
  OrderStatus,
  BadRequestError,
} from "@lt-ticketing/common";
import { OrderCreatedPublisher } from "../events/publishers/order-created-publisher";
import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

const EXP_TIME_SEC = 1 * 30;
const router = express.Router();

router.post(
  "/api/orders",
  requireAuth,
  [
    body("ticketId")
      .not()
      .isEmpty()
      .custom((input: string) => mongoose.Types.ObjectId.isValid(input))
      .withMessage("Ticket id must be defined."),
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    const { ticketId } = req.body;
    logger.info("Received order creation request", {
      ticketId,
      userId: req.currentUser!.id,
    });

    const ticket = await Ticket.findById(ticketId);
    if (!ticket) {
      logger.warn("Ticket not found", { ticketId });
      throw new NotFoundError();
    }

    const isReserved = await ticket.isReserved();
    if (isReserved) {
      logger.warn("Ticket already reserved", { ticketId });
      throw new BadRequestError("Ticket already reserved.");
    }

    const expirationTime = new Date();
    expirationTime.setSeconds(expirationTime.getSeconds() + EXP_TIME_SEC);

    const order = Order.build({
      userId: req.currentUser!.id,
      status: OrderStatus.Created,
      expiresAt: expirationTime,
      ticket,
    });
    await order.save();

    logger.info("Order created", { order });

    await new OrderCreatedPublisher(rabbitmqWrapper.channel).publish({
      id: order.id,
      status: order.status,
      userId: order.userId,
      expiresAt: order.expiresAt.toISOString(),
      version: order.version,
      ticket: {
        id: ticket.id,
        price: ticket.price,
      },
    });

    logger.info("Order creation event published", { orderId: order.id });

    res.status(201).send(order);
  }
);

export { router as newOrderRouter };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/index.ts
================================================================================
import express, { Request, Response } from 'express';
import { requireAuth } from '@lt-ticketing/common';
import { Order } from '../models/order';

const router = express.Router();

router.get(
    '/api/orders', 
    requireAuth,
    async (req: Request, res: Response) => {
        const orders = await Order.find({
            userId: req.currentUser!.id
        }).populate('ticket');
        
        res.send(orders);
    }
);

export { router as indexOrderRouter };

================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/show.ts
================================================================================
import express, { Request, Response } from "express";
import {
  NotAuthorizedError,
  NotFoundError,
  requireAuth,
} from "@lt-ticketing/common";
import { Order } from "../models/order";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.get(
  "/api/orders/:orderId",
  requireAuth,
  async (req: Request, res: Response) => {
    const { orderId } = req.params;
    logger.info("Received order retrieval request", {
      orderId,
      userId: req.currentUser!.id,
    });

    const order = await Order.findById(orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { order });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to view order", {
        order,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    logger.info("Order retrieved", { order });

    res.send(order);
  }
);

export { router as showOrderRouter };


================================================================================
File: /Users/luketchang/code/ticketing/orders/src/routes/delete.ts
================================================================================
import express, { Request, Response } from "express";
import {
  requireAuth,
  OrderStatus,
  NotFoundError,
  NotAuthorizedError,
} from "@lt-ticketing/common";
import { Order } from "../models/order";
import { OrderCancelledPublisher } from "../events/publishers/order-cancelled-publisher";
import { rabbitmqWrapper } from "../rabbitmq-wrapper";
import { logger } from "@lt-ticketing/common";

const router = express.Router();

router.delete(
  "/api/orders/:orderId",
  requireAuth,
  async (req: Request, res: Response) => {
    const { orderId } = req.params;
    logger.info("Received order deletion request", {
      orderId,
      userId: req.currentUser!.id,
    });

    const order = await Order.findById(orderId).populate("ticket");

    if (!order) {
      logger.warn("Order not found", { orderId });
      throw new NotFoundError();
    }
    if (order.userId !== req.currentUser!.id) {
      logger.warn("Not authorized to delete order", {
        orderId,
        userId: req.currentUser!.id,
      });
      throw new NotAuthorizedError();
    }

    logger.info("Order cancelled", { orderId });
    order.status = OrderStatus.Cancelled;
    await order.save();

    logger.info("Publishing order cancellation event", { orderId });
    await new OrderCancelledPublisher(rabbitmqWrapper.channel).publish({
      id: order.id,
      version: order.version,
      ticket: {
        id: order.ticket.id,
      },
    });

    res.status(204).send(order);
  }
);

export { router as deleteOrderRouter };

