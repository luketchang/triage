import { logger } from "@triage/common";
import { execSync } from "child_process";
import * as fs from "fs/promises";
import * as path from "path";
import { CollectedFiles } from "../types";

// Constants
export const EXCLUDED_DIRS = new Set([
  "venv",
  ".venv",
  "site-packages",
  "__pycache__",
  "node_modules",
  ".git",
  "api_clients",
  "__test__",
  "rapidsnark",
  "test",
  "graph-node",
  "doc-images",
  "fixtures",
  ".yarn",
  ".changeset",
  ".github",
  "subgraph",
  "types",
  "autogenerated",
  "dist",
  "packages",
  "tools",
  "bindings",
]);

export const EXCLUDED_EXTENSIONS = [".json"];

/**
 * Checks if a path should be excluded based on the EXCLUDED_DIRS set
 */
export function isExcluded(filePath: string): boolean {
  return filePath.split(path.sep).some((part) => EXCLUDED_DIRS.has(part));
}

/**
 * Collects files from a directory, filtering by allowed extensions
 */
export async function collectFiles(
  directory: string,
  allowedExtensions: string[],
  repoRoot: string
): Promise<CollectedFiles> {
  const fileTree: string[] = [];
  const pathToSourceCode: Record<string, string> = {};

  async function walkDir(currentPath: string) {
    try {
      const entries = await fs.readdir(currentPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(currentPath, entry.name);

        if (entry.isDirectory()) {
          if (!isExcluded(fullPath)) {
            await walkDir(fullPath);
          }
        } else if (entry.isFile()) {
          const ext = path.extname(entry.name);
          if (EXCLUDED_EXTENSIONS.includes(ext)) {
            continue;
          }

          if (allowedExtensions.includes(ext) && !isExcluded(fullPath)) {
            const relPath = path.relative(repoRoot, fullPath);
            fileTree.push(relPath);

            try {
              const content = await fs.readFile(fullPath, "utf-8");
              pathToSourceCode[relPath] = content;
            } catch (error) {
              pathToSourceCode[relPath] = `Error reading file: ${error}`;
              logger.error(`Could not read file ${fullPath}: ${error}`);
            }
          }
        }
      }
    } catch (error) {
      logger.error(`Error walking directory ${currentPath}: ${error}`);
    }
  }

  await walkDir(directory);
  return { fileTree, pathToSourceCode };
}

/**
 * Reads source code from a list of file paths
 */
export async function getSourceCodeFromPaths(filePaths: string[]): Promise<Record<string, string>> {
  const pathToSourceCode: Record<string, string> = {};

  for (const filePath of filePaths) {
    try {
      const content = await fs.readFile(filePath, "utf-8");
      pathToSourceCode[filePath] = content;
    } catch (error) {
      pathToSourceCode[filePath] = `Error reading file: ${error}`;
      logger.error(`Could not read file ${filePath}: ${error}`);
    }
  }

  return pathToSourceCode;
}

/**
 * Generates a tree string representation from a list of file paths
 */
export function generateTreeString(filePaths: string[]): string {
  if (filePaths.length === 0) {
    return "";
  }

  // Sort files for a more organized tree
  const sortedFiles = [...filePaths].sort();

  // Simple indentation-based tree representation
  let result = "";

  for (const file of sortedFiles) {
    const parts = file.split(file.includes("/") ? "/" : "\\");
    let line = "";

    // Add indentation based on path depth
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;

      if (i === 0) {
        // Root level
        line += isLast ? "└── " : "├── ";
      } else {
        // Add indentation
        line += "│   ".repeat(i) + (isLast ? "└── " : "├── ");
      }

      line += part + "\n";
    }

    result += line;
  }

  return result;
}

/**
 * Clones a repository to the specified directory
 */
export function cloneRepository(repoUrl: string, cloneDir: string, branch?: string): void {
  logger.info(`Cloning repository ${repoUrl} into ${cloneDir}...`);

  const cmd = ["git", "clone"];
  if (branch) {
    cmd.push("--branch", branch);
  }
  cmd.push(repoUrl, cloneDir);

  try {
    execSync(cmd.join(" "), { stdio: "pipe" });
    logger.info("Repository clone completed.");
  } catch (error) {
    const errorMsg = `Git clone failed: ${error}`;
    logger.error(errorMsg);
    throw new Error(errorMsg);
  }
}

/**
 * Lists major directories in a repository
 */
export async function listMajorDirectories(repoPath: string): Promise<string[]> {
  const dirs: string[] = [];

  try {
    const items = await fs.readdir(repoPath, { withFileTypes: true });

    for (const item of items) {
      if (item.isDirectory()) {
        const fullPath = path.join(repoPath, item.name);
        if (!isExcluded(fullPath)) {
          dirs.push(fullPath);
        }
      }
    }
  } catch (error) {
    logger.error(`Error listing directories in ${repoPath}: ${error}`);
  }

  return dirs;
}
