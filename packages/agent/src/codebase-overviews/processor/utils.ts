import { logger } from "@triage/common";
import * as path from "path";
import { CollectedFiles } from "../types";

// Constants
export const EXCLUDED_DIRS = new Set([
  "venv",
  ".venv",
  "site-packages",
  "__pycache__",
  "node_modules",
  ".git",
  "api_clients",
  "__test__",
  "rapidsnark",
  "test",
  "graph-node",
  "doc-images",
  "fixtures",
  ".yarn",
  ".changeset",
  ".github",
  "subgraph",
  "types",
  "autogenerated",
  "dist",
  "packages",
  "tools",
  "bindings",
]);

export const EXCLUDED_EXTENSIONS = [".json"];

const MAX_FILE_SIZE = 1024 * 1024; // 1MB

/**
 * Checks if a path should be excluded based on the EXCLUDED_DIRS set
 */
export function isExcluded(filePath: string): boolean {
  return filePath.split(path.sep).some((part) => EXCLUDED_DIRS.has(part));
}

/**
 * Collects files from a directory using repomix output
 */
export async function collectFiles(
  directory: string,
  allowedExtensions: string[],
  repoRoot: string,
  repomixOutput: string
): Promise<CollectedFiles> {
  const fileTree: string[] = [];
  const pathToSourceCode: Record<string, string> = {};

  try {
    // Extract directory structure
    const dirStructureMatch = repomixOutput.match(
      /<directory_structure>([\s\S]*?)<\/directory_structure>/
    );
    if (dirStructureMatch && dirStructureMatch[1]) {
      const allPaths = dirStructureMatch[1].trim().split("\n");
      // Filter paths to only include those under the target directory
      const relativeDir = path.relative(repoRoot, directory);
      fileTree.push(...allPaths.filter((p) => p.startsWith(relativeDir)));
    }

    // Extract file contents
    const fileMatches = repomixOutput.matchAll(/<file path="([^"]+)">([\s\S]*?)<\/file>/g);
    for (const match of fileMatches) {
      const [, filePath, content] = match;
      if (filePath && content) {
        const relativePath = path.relative(repoRoot, filePath);
        if (relativePath.startsWith(directory)) {
          const ext = path.extname(filePath);
          if (allowedExtensions.includes(ext)) {
            pathToSourceCode[relativePath] = content;
          }
        }
      }
    }

    return { fileTree, pathToSourceCode };
  } catch (error) {
    logger.error(`Error parsing repomix output: ${error}`);
    return { fileTree: [], pathToSourceCode: {} };
  }
}

/**
 * Reads source code from a list of file paths using repomix output
 */
export async function getSourceCodeFromPaths(
  filePaths: string[],
  repomixOutput: string
): Promise<Record<string, string>> {
  const pathToSourceCode: Record<string, string> = {};

  try {
    const fileMatches = repomixOutput.matchAll(/<file path="([^"]+)">([\s\S]*?)<\/file>/g);
    for (const match of fileMatches) {
      const [, filePath, content] = match;
      if (filePath && content && filePaths.includes(filePath)) {
        pathToSourceCode[filePath] = content;
      }
    }

    return pathToSourceCode;
  } catch (error) {
    logger.error(`Error parsing repomix output: ${error}`);
    return {};
  }
}

/**
 * Generates a tree string representation from a list of file paths
 */
export function generateTreeString(filePaths: string[]): string {
  if (filePaths.length === 0) {
    return "No files found";
  }
  return filePaths.join("\n");
}

/**
 * Lists major directories in a repository, fallback
 */
export async function listMajorDirectories(
  repoPath: string,
  repomixOutput?: string | null
): Promise<string[]> {
  if (!repomixOutput) {
    logger.warn("No repomix output provided to listMajorDirectories");
    return [];
  }

  // Extract directory structure from repomix output
  const dirStructureMatch = repomixOutput.match(
    /<directory_structure>([\s\S]*?)<\/directory_structure>/
  );

  if (!dirStructureMatch || !dirStructureMatch[1]) {
    logger.warn("Could not extract directory structure from repomix output");
    return [];
  }

  const directoryStructure = dirStructureMatch[1].trim().split("\n");
  const majorDirs = new Set<string>();

  // Process each line of the directory structure
  for (const line of directoryStructure) {
    // Skip empty lines
    if (!line.trim()) continue;

    // Files are indicated by no trailing slash
    const isFile = !line.trim().endsWith("/");

    if (isFile) {
      // Extract the top-level directory from the file path
      const parts = line.split("/");
      if (parts.length > 1) {
        // Add the top directory to our set
        const topDir = parts[0];
        if (topDir && !topDir.startsWith(".") && topDir !== "node_modules") {
          majorDirs.add(topDir);
        }
      }
    }
  }

  // Convert to absolute paths
  return Array.from(majorDirs).map((dir) => path.join(repoPath, dir));
}
