import { logger } from "@triage/common";
import * as fs from "fs/promises";
import * as path from "path";
import { CollectedFiles } from "../types";

// Constants
export const EXCLUDED_DIRS = new Set([
  "venv",
  ".venv",
  "site-packages",
  "__pycache__",
  "node_modules",
  ".git",
  "api_clients",
  "__test__",
  "rapidsnark",
  "test",
  "graph-node",
  "doc-images",
  "fixtures",
  ".yarn",
  ".changeset",
  ".github",
  "subgraph",
  "types",
  "autogenerated",
  "dist",
  "packages",
  "tools",
  "bindings",
]);

export const EXCLUDED_EXTENSIONS = [".json"];

const MAX_FILE_SIZE = 1024 * 1024; // 1MB

/**
 * Checks if a path should be excluded based on the EXCLUDED_DIRS set
 */
export function isExcluded(filePath: string): boolean {
  return filePath.split(path.sep).some((part) => EXCLUDED_DIRS.has(part));
}

/**
 * Collects files from a directory using repomix output
 */
export async function collectFiles(
  directory: string,
  allowedExtensions: string[],
  repoRoot: string,
  repomixOutput: string
): Promise<CollectedFiles> {
  const fileTree: string[] = [];
  const pathToSourceCode: Record<string, string> = {};

  try {
    // Extract directory structure
    const dirStructureMatch = repomixOutput.match(
      /<directory_structure>([\s\S]*?)<\/directory_structure>/
    );
    if (dirStructureMatch && dirStructureMatch[1]) {
      const allPaths = dirStructureMatch[1].trim().split("\n");
      // Filter paths to only include those under the target directory
      const relativeDir = path.relative(repoRoot, directory);
      fileTree.push(...allPaths.filter((p) => p.startsWith(relativeDir)));
    }

    // Extract file contents
    const fileMatches = repomixOutput.matchAll(/<file path="([^"]+)">([\s\S]*?)<\/file>/g);
    for (const match of fileMatches) {
      const [, filePath, content] = match;
      if (filePath && content) {
        const relativePath = path.relative(repoRoot, filePath);
        if (relativePath.startsWith(directory)) {
          const ext = path.extname(filePath);
          if (allowedExtensions.includes(ext)) {
            pathToSourceCode[relativePath] = content;
          }
        }
      }
    }

    return { fileTree, pathToSourceCode };
  } catch (error) {
    logger.error(`Error parsing repomix output: ${error}`);
    return { fileTree: [], pathToSourceCode: {} };
  }
}

/**
 * Reads source code from a list of file paths using repomix output
 */
export async function getSourceCodeFromPaths(
  filePaths: string[],
  repomixOutput: string
): Promise<Record<string, string>> {
  const pathToSourceCode: Record<string, string> = {};

  try {
    const fileMatches = repomixOutput.matchAll(/<file path="([^"]+)">([\s\S]*?)<\/file>/g);
    for (const match of fileMatches) {
      const [, filePath, content] = match;
      if (filePath && content && filePaths.includes(filePath)) {
        pathToSourceCode[filePath] = content;
      }
    }

    return pathToSourceCode;
  } catch (error) {
    logger.error(`Error parsing repomix output: ${error}`);
    return {};
  }
}

/**
 * Generates a tree string representation from a list of file paths
 */
export function generateTreeString(filePaths: string[]): string {
  if (filePaths.length === 0) {
    return "No files found";
  }
  return filePaths.join("\n");
}

/**
 * Lists major directories in a repository
 */
export async function listMajorDirectories(repoPath: string): Promise<string[]> {
  const dirEntries = await fs.readdir(repoPath, { withFileTypes: true });
  const majorDirs: string[] = [];

  for (const entry of dirEntries) {
    if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules") {
      majorDirs.push(path.join(repoPath, entry.name));
    }
  }

  return majorDirs;
}
